<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="约定俗称 # 消息号命名规范 # 为了client与server的统一, 消息号统一使用驼峰式命名, exp: SubQueryGoldRooms 第一个字段 归属标志 可能的赋值 Sub C端向S端查询 Cmd S端返回给C端 L2G logon->Game G2L game->logon 只有Lgon, game间的消息号使用 LG字样, 其他全部是Sub, Cmd 第二个字段 意图 增删改查 第三个字段 对象 被op对象 &ndash; 可以没有 第四个字段 消息号含义 结构体的命名为 消息号前面增加Str 函数的命名为 消息号前面增加On 玩家的桌子号 # player.tableid 含义: 玩家在哪个桌子上 用途: 登录的时候 判断断线重连 进入table时的校验, 防止加入2张桌子 状态变化: roomSvr table加入|坐下, 设置为桌子的tableid roomSvr table离开, 如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE matchSvr 报名成功, 设置为MATCH_TABLE matchSvr 取消报名, 设置为INVALID_TABLE 房间流程 # 创建房间 &ndash; 门票检测, 房间规则显示 RoomServer处理 房间规则使用rule_arry结构体传送给客户端显示 加入房间 &ndash; 门票检测 GameServer处理 门票检测时 也会进行游戏资格检测 房间规则在子游戏的显示 RoomServer frame处理 frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息 玩家信息在子游戏的显示 RoomServer frame处理 玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client client根据动作, 判断是绘制还是删除玩家 玩家财富变更后, LogonServer会通知client, 更改大厅的显示 如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示 即SubGame子游戏不再提供玩家分数相关信息给client 游戏开始|一小局后 &ndash; 门票扣除 RoomServer frame处理 门票扣除信息 在RoomRuleCom中, 由GameServer生成 每小局游戏结束 &ndash; 游戏小局结算 RoomServer frame处理 小局结算写分 战绩记录 录像回放 每局游戏结束后 &ndash; 游戏资格检测 RoomServer frame处理 数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理 server-gate # logon # 重复登陆 # 在当前gateSvr中重复登陆 auto player = player_manager."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qygame.github.io/blog/posts/server/"><meta property="og:site_name" content="QYGame"><meta property="og:title" content="QYGame"><meta property="og:description" content="约定俗称 # 消息号命名规范 # 为了client与server的统一, 消息号统一使用驼峰式命名, exp: SubQueryGoldRooms 第一个字段 归属标志 可能的赋值 Sub C端向S端查询 Cmd S端返回给C端 L2G logon->Game G2L game->logon 只有Lgon, game间的消息号使用 LG字样, 其他全部是Sub, Cmd 第二个字段 意图 增删改查 第三个字段 对象 被op对象 – 可以没有 第四个字段 消息号含义 结构体的命名为 消息号前面增加Str 函数的命名为 消息号前面增加On 玩家的桌子号 # player.tableid 含义: 玩家在哪个桌子上 用途: 登录的时候 判断断线重连 进入table时的校验, 防止加入2张桌子 状态变化: roomSvr table加入|坐下, 设置为桌子的tableid roomSvr table离开, 如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE matchSvr 报名成功, 设置为MATCH_TABLE matchSvr 取消报名, 设置为INVALID_TABLE 房间流程 # 创建房间 – 门票检测, 房间规则显示 RoomServer处理 房间规则使用rule_arry结构体传送给客户端显示 加入房间 – 门票检测 GameServer处理 门票检测时 也会进行游戏资格检测 房间规则在子游戏的显示 RoomServer frame处理 frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息 玩家信息在子游戏的显示 RoomServer frame处理 玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client client根据动作, 判断是绘制还是删除玩家 玩家财富变更后, LogonServer会通知client, 更改大厅的显示 如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示 即SubGame子游戏不再提供玩家分数相关信息给client 游戏开始|一小局后 – 门票扣除 RoomServer frame处理 门票扣除信息 在RoomRuleCom中, 由GameServer生成 每小局游戏结束 – 游戏小局结算 RoomServer frame处理 小局结算写分 战绩记录 录像回放 每局游戏结束后 – 游戏资格检测 RoomServer frame处理 数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理 server-gate # logon # 重复登陆 # 在当前gateSvr中重复登陆 auto player = player_manager."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><title>Server | QYGame</title>
<link rel=manifest href=/blog/manifest.json><link rel=icon href=/blog/favicon.png><link rel=canonical href=https://qygame.github.io/blog/posts/server/><link rel=stylesheet href=/blog/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/blog/fuse.min.js></script><script defer src=/blog/en.search.min.278f1df1db7b3431d38ce1869794e60694b36ca592adeca986590bcab9c997ce.js integrity="sha256-J48d8dt7NDHTjOGGl5TmBpSzbKWSreyphlkLyrnJl84=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/blog/><span>QYGame</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-d09102f6d18a91f5dc9f0da2dfb6a537 class=toggle>
<label for=section-d09102f6d18a91f5dc9f0da2dfb6a537 class="flex justify-between"><a role=button>client</a></label><ul><li><input type=checkbox id=section-39baa70203a8a50cdb904b07d583bf34 class=toggle>
<label for=section-39baa70203a8a50cdb904b07d583bf34 class="flex justify-between"><a role=button>unity, android, ios基础</a></label><ul><li><a href=/blog/docs/client/base/unity/>unity</a></li><li><a href=/blog/docs/client/base/android/>Android</a></li></ul></li><li><input type=checkbox id=section-9359d3f28129ad095652cf9ef22808a3 class=toggle>
<label for=section-9359d3f28129ad095652cf9ef22808a3 class="flex justify-between"><a role=button>打包流程</a></label><ul><li><a href=/blog/docs/client/build/build/>注意事项</a></li><li><a href=/blog/docs/client/build/build_apple/>苹果打包流程</a></li></ul></li><li><a href=/blog/docs/client/env_init/>环境搭建</a></li><li><input type=checkbox id=section-3220090dd26cfc128f101bf2c1583e6c class=toggle>
<label for=section-3220090dd26cfc128f101bf2c1583e6c class="flex justify-between"><a role=button>sdk介绍</a></label><ul><li><a href=/blog/docs/client/sdk/bdframework/>BDFramework</a></li><li><a href=/blog/docs/client/sdk/sharesdk/>ShareSDK</a></li></ul></li><li><a href=/blog/docs/client/subgame/>子游戏</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/blog/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Server</strong>
<label for=toc-control><img src=/blog/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#约定俗称>约定俗称</a><ul><li></li></ul></li><li><a href=#server-gate>server-gate</a><ul><li><a href=#logon>logon</a></li><li><a href=#game>game</a></li><li><a href=#center>center</a></li><li><a href=#server-match><span class="org-todo todo TODO">TODO</span> server&ndash;match</a></li><li><a href=#server-rank><span class="org-todo todo TODO">TODO</span> server&ndash;rank</a></li><li><a href=#server-task>server&ndash;task</a></li></ul></li><li><a href=#server-db>server&ndash;db</a><ul><li><a href=#对外接口>对外接口</a></li><li><a href=#参考资料>参考资料</a></li></ul></li><li><a href=#server-room>server&ndash;room</a><ul><li><a href=#对外接口>对外接口</a></li><li><a href=#table设计思路>table设计思路</a></li><li><a href=#战绩-and-and-录像回放>战绩 && 录像回放</a></li><li><a href=#小局结束-数据处理>小局结束 数据处理</a></li><li><a href=#玩家动作-坐下-起立-离开-解散-换桌--金币场>玩家动作 坐下|起立|离开|解散|换桌(金币场)</a></li><li><a href=#玩家状态>玩家状态</a></li><li><a href=#椅子视图>椅子视图</a></li><li><a href=#tableid生成方式>tableid生成方式</a></li><li><a href=#房间配置加载>房间配置加载</a></li></ul></li><li><a href=#server-子游戏>server&ndash;子游戏</a><ul><li><a href=#组织架构>组织架构</a></li><li><a href=#牌类数据描述>牌类数据描述</a></li><li><a href=#protobuf结构>protobuf结构</a></li></ul></li><li><a href=#redis>redis</a><ul><li><a href=#已使用字段>已使用字段</a></li><li><a href=#已使用lock字段>已使用lock字段</a></li></ul></li><li><a href=#server-redis><span class="org-todo todo TODO">TODO</span> server&ndash;redis</a></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/blog/posts/server/>Server</a></h1><h2 id=约定俗称>约定俗称
<a class=anchor href=#%e7%ba%a6%e5%ae%9a%e4%bf%97%e7%a7%b0>#</a></h2><h4 id=消息号命名规范>消息号命名规范
<a class=anchor href=#%e6%b6%88%e6%81%af%e5%8f%b7%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83>#</a></h4><p>为了client与server的统一, 消息号统一使用驼峰式命名, exp: SubQueryGoldRooms<br></p><ul><li><p>第一个字段 归属标志<br>可能的赋值<br></p><ol><li>Sub C端向S端查询<br></li><li>Cmd S端返回给C端<br></li><li>L2G logon->Game<br></li><li>G2L game->logon<br></li></ol><pre><code class=language-text>只有Lgon, game间的消息号使用 LG字样, 其他全部是Sub, Cmd
</code></pre></li><li><p>第二个字段 意图 增删改查<br></p></li><li><p>第三个字段 对象 被op对象 &ndash; 可以没有<br></p></li><li><p>第四个字段 消息号含义<br></p></li></ul><p>结构体的命名为 消息号前面增加Str<br>函数的命名为 消息号前面增加On<br></p><h4 id=玩家的桌子号>玩家的桌子号
<a class=anchor href=#%e7%8e%a9%e5%ae%b6%e7%9a%84%e6%a1%8c%e5%ad%90%e5%8f%b7>#</a></h4><p>player.tableid<br>含义:<br>玩家在哪个桌子上<br></p><p>用途:<br></p><ol><li>登录的时候 判断断线重连<br></li><li>进入table时的校验, 防止加入2张桌子<br></li></ol><p>状态变化:<br></p><ol><li>roomSvr table加入|坐下, 设置为桌子的tableid<br></li><li>roomSvr table离开, 如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE<br></li><li>matchSvr 报名成功, 设置为MATCH_TABLE<br></li><li>matchSvr 取消报名, 设置为INVALID_TABLE<br></li></ol><h4 id=房间流程>房间流程
<a class=anchor href=#%e6%88%bf%e9%97%b4%e6%b5%81%e7%a8%8b>#</a></h4><ol><li><p><input checked disabled type=checkbox> 创建房间 &ndash; 门票检测, 房间规则显示<br></p><pre><code class=language-text>RoomServer处理
房间规则使用rule_arry结构体传送给客户端显示
</code></pre></li><li><p><input checked disabled type=checkbox> 加入房间 &ndash; 门票检测<br></p><pre><code class=language-text>GameServer处理
门票检测时 也会进行游戏资格检测
</code></pre></li><li><p><input checked disabled type=checkbox> 房间规则在子游戏的显示<br></p><pre><code class=language-text>RoomServer frame处理
frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息
</code></pre></li><li><p><input checked disabled type=checkbox> 玩家信息在子游戏的显示<br></p><pre><code class=language-text>RoomServer frame处理
玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client
client根据动作, 判断是绘制还是删除玩家
玩家财富变更后, LogonServer会通知client, 更改大厅的显示
                如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示
                即SubGame子游戏不再提供玩家分数相关信息给client
</code></pre></li><li><p><input checked disabled type=checkbox> 游戏开始|一小局后 &ndash; 门票扣除<br></p><pre><code class=language-text>RoomServer frame处理
门票扣除信息 在RoomRuleCom中, 由GameServer生成
</code></pre></li><li><p><input checked disabled type=checkbox> 每小局游戏结束 &ndash; 游戏小局结算<br></p><pre><code class=language-text>RoomServer frame处理
</code></pre><ol><li>小局结算写分<br></li><li>战绩记录<br></li><li>录像回放<br></li></ol></li><li><p><input checked disabled type=checkbox> 每局游戏结束后 &ndash; 游戏资格检测<br></p><pre><code class=language-text>RoomServer frame处理
数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理
</code></pre></li></ol><h2 id=server-gate>server-gate
<a class=anchor href=#server-gate>#</a></h2><h3 id=logon>logon
<a class=anchor href=#logon>#</a></h3><h4 id=重复登陆>重复登陆
<a class=anchor href=#%e9%87%8d%e5%a4%8d%e7%99%bb%e9%99%86>#</a></h4><p><strong>在当前gateSvr中重复登陆</strong><br>auto player = player_manager.get(uid);<br>player.gatesvr_session != player.current_session 就认为是重复登陆<br></p><p><strong>在所有gateSvr中重复登陆</strong><br>redis中存在 key=gate_$uid, val=gatesvrid<br>redis.val != current_serverid 说明该uid正在其他gateSvr上. 认为重复登陆<br></p><p><strong>重复登陆处理</strong><br>在当前gateSvr中重复登陆, 可以直接关闭旧的连接<br>在其他gateSvr中重复登陆, 需要通过 ?? 通知对应的gateSvr, 关闭玩家连接<br></p><h4 id=断线重连>断线重连
<a class=anchor href=#%e6%96%ad%e7%ba%bf%e9%87%8d%e8%bf%9e>#</a></h4><p><strong>判断依据</strong><br>玩家登陆的时候,<br>redis中存在 key=room_$uid, val=roomsvrid<br>gateSvr会向roomSvr确认玩家是否真的在roomSvr中,<br>如果roomSvr返回在, 则认为玩家是断线重连<br></p><p><strong>断线处理</strong><br></p><ol><li>gateSvr更新player的roomsvrid信息<br></li><li>通知client<br></li></ol><h3 id=game>game
<a class=anchor href=#game>#</a></h3><p>房间信息查询<br>数据来源于roomSvr. roomSvr连接成功之后, 会主动推送<br></p><h4 id=数据格式>数据格式
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f>#</a></h4><p>房卡场 &ndash; 查询房间配置:<br>file: cfg_fk.hh<br>data: map&lt;kindid, rule_arry><br></p><p>金币场 &ndash; 查询金币场信息<br>file: cfg_gold.hh<br>data: map&lt;kindid, vector&lt;gold_msg>><br></p><p>roomSvr信息<br>file: server_manager<br>data:<br>map&lt;session, vec&lt;kind+level>><br>map&lt;vec&lt;kind+level>, session><br></p><p>保留roomSvr的意义:<br>如果roomSvr与gateSvr断开连接了, 那么就可以实时的更新3个data数据.<br>保证client那边看到的永远是可用的服务器<br></p><h3 id=center>center
<a class=anchor href=#center>#</a></h3><p>路由clien &lt;->roomSvr<br></p><ul><li>client -> gate -> roomsvr<br>依据&lt;player, roomsvrid> &lt;x_session, roomsvrid>路由<br>不使用redis的room_$uid是因为redis承载量不够<br></li><li>roomsvr -> gate -> client<br>依据&lt;player, client_session>路由<br></li></ul><p>&lt;player, roomsvrid> 在player_manager中维护<br></p><ol><li>玩家登陆成功时候, 根据redis中room_$uid来确认<br></li><li>玩家在roomSvr中加入或退出的时候, roomSvr也会主动推送给gateSvr.<br></li></ol><p>&lt;x_session, roomsvrid> 在server_manager中维护<br></p><h4 id=对外接口>对外接口
<a class=anchor href=#%e5%af%b9%e5%a4%96%e6%8e%a5%e5%8f%a3>#</a></h4><ul><li>SetRoomID(uid, roomsvrid)<br></li></ul><h3 id=server-match><span class="org-todo todo TODO">TODO</span> server&ndash;match
<a class=anchor href=#server-match>#</a></h3><h4 id=设计理念>设计理念
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5>#</a></h4><p>matchSvr负责维护 {uid, score} 排行,<br>具体的数据是roomSvr通知的matchSvr<br></p><p>match没有必要把同排行的人放到一个roomSvr, 因此不需要指定roomSvr<br></p><h4 id=组织架构>组织架构
<a class=anchor href=#%e7%bb%84%e7%bb%87%e6%9e%b6%e6%9e%84>#</a></h4><pre><code class=language-text>kind1  --  match-type 1  -- match 1 -- {对应一系列桌子}
                         -- ....
                         -- match N
       --  ....
       --  match-type N
....
kind N
</code></pre><h4 id=流程>流程
<a class=anchor href=#%e6%b5%81%e7%a8%8b>#</a></h4><ol><li>玩家申请加入某个比赛场match_type, 如果没有空的match, 则创建一个match, 放入玩家<br>设置其tableid为MATCH_TABLE, 防止进入其他桌子<br>如果玩家取消比赛, tableid重置为INVALID_TABLE<br>玩家掉线的时候, 如果还在比赛排队状态(tableid为MATCH_TABLE), 则按取消比赛处理<br></li><li>当match满足触发条件之后, 开始比赛<br>matchSvr把玩家分组, 并通知roomSvr创建桌子<br></li><li>roomSvr进行游戏, 当table大局结束的时候, 把数据(score)返回给matchSvr<br></li><li>matchSvr进行排序, 重新分组, 继续通知roomSvr开始游戏<br></li><li>循环直至比赛结束为止<br></li></ol><h4 id=依赖关系>依赖关系
<a class=anchor href=#%e4%be%9d%e8%b5%96%e5%85%b3%e7%b3%bb>#</a></h4><p>依赖GameSvr, 需要GameSvr提供的GetRoomRule()接口<br></p><h4 id=缺陷>缺陷
<a class=anchor href=#%e7%bc%ba%e9%99%b7>#</a></h4><p>有状态的, 需要后期改为无状态服务器<br></p><h4 id=配置文件>配置文件
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h4><p>配置文件放在subgames/kinid/kindid.match中<br></p><h3 id=server-rank><span class="org-todo todo TODO">TODO</span> server&ndash;rank
<a class=anchor href=#server-rank>#</a></h3><h4 id=对外接口>对外接口
<a class=anchor href=#%e5%af%b9%e5%a4%96%e6%8e%a5%e5%8f%a3>#</a></h4><ul><li>PushRank(ranktype, uid, score)<br></li></ul><h4 id=配置文件>配置文件
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h4><p><strong>配置文件放在database rank表</strong><br></p><table><thead><tr><th>id</th><th>rank_name</th><th>rank_desc</th><th>type</th><th>sortid</th><th>award</th><th>valid</th></tr></thead><tbody><tr><td>自增</td><td>名字</td><td>描述</td><td>类型(唯一标志)</td><td>优先级</td><td>奖励</td><td>是否开启</td></tr></tbody></table><h4 id=定时功能的设计>定时功能的设计
<a class=anchor href=#%e5%ae%9a%e6%97%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e8%ae%be%e8%ae%a1>#</a></h4><p>自定义定时操作<br>缺点非常明显, 如果Svr挂了, 那么可能会导致数据错乱<br>所以需要额外考虑svr挂掉的情况<br></p><h3 id=server-task>server&ndash;task
<a class=anchor href=#server-task>#</a></h3><h4 id=对外接口>对外接口
<a class=anchor href=#%e5%af%b9%e5%a4%96%e6%8e%a5%e5%8f%a3>#</a></h4><ul><li>PushTask(task_type, uid, score)<br></li></ul><h4 id=流程图>流程图
<a class=anchor href=#%e6%b5%81%e7%a8%8b%e5%9b%be>#</a></h4><pre><code class=language-text>+--------+
| start  |
+--------+
    |
    |
    v
+--------+  否
| 触发   |------------+
+--------+            |
  是|                 |
    |                 |
    v                 |
+--------+  否        |
|  完成  | -----+     |
+--------+      |     |
    |           |     |
 是 |           |     |
    v           |     |
+--------+      |     |
| updata | &lt;----+     |
+--------+            |
    |                 |
+---v----+            |
| end    | &lt;----------+
+--------+
</code></pre><ol><li>触发条件判断<br><ul><li>时间start - end范围<br></li><li>特定kind, 特定room_level下的任务.<br>比如完成斗地主高级场一次<br></li><li>用户身份的限定<br>比如vip才可完成的任务<br></li></ul></li><li>完成条件的判断<br><ol><li>需要先根据周期重置来重置任务完成状况<br></li><li>任务完成状况与task配置中的任务step_all比较, 判断是否完成<br></li></ol></li><li>update<br>更新任务完成状况<br></li></ol><h4 id=配置文件-and-and-中间状态>配置文件 && 中间状态
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6-and-and-%e4%b8%ad%e9%97%b4%e7%8a%b6%e6%80%81>#</a></h4><p><strong>配置文件放到database task表</strong><br></p><table><thead><tr><th>名称</th><th>描述</th><th>类型</th><th>优先级</th><th>开始时间</th><th>结束时间</th><th>重置周期</th><th>其他触发限制</th><th>总步数</th><th>奖励配置</th></tr></thead><tbody><tr><td>name</td><td>desc</td><td>type</td><td>priority</td><td>start_time</td><td>end_time</td><td>reset_period</td><td>on_xml</td><td>step_all</td><td>award</td></tr></tbody></table><p>type解释,<br>斗地主初级场1次, 斗地主初级场2次, 斗地主初级场3次<br>那么他们的type可以一致, 并设置priority分别为1,2,3<br>这样就可以认为这三个任务是阶段性任务. 先完成斗地主初级场1次后, 才会显示斗地主初级场2次;<br>完成斗地主初级场2次后,才会显示斗地主初级场3次. 形成一个阶段<br></p><p>所以type相同, 认为是同一种类型任务(触发流程, 完成流程都一致), 而priority可以区分其阶段.<br></p><p><strong>中间状态放到redis task_status_$uid_$taskid表</strong><br></p><table><thead><tr><th>uid</th><th>任务id</th><th>当前步数</th><th>任务完成时间</th><th>任务状态</th></tr></thead><tbody><tr><td>uid</td><td>taskid</td><td>step_current</td><td>time</td><td>status</td></tr></tbody></table><p>time应该是任务完成的时间. 昨天完成的时间, 到了今天也会重置<br>status 0 未完成, 1完成未领奖, 2完成已领奖<br></p><h4 id=任务类的设计>任务类的设计
<a class=anchor href=#%e4%bb%bb%e5%8a%a1%e7%b1%bb%e7%9a%84%e8%ae%be%e8%ae%a1>#</a></h4><ol><li>Task<br><ul><li>tagTask 任务配置的数据结构<br></li><li>触发逻辑判断 task::bOn(&mldr;) 入参可能较多<br></li><li>完成逻辑判断 task::bComplete(tagTaskStatus)<br></li></ul></li><li>TaskManager<br><ul><li>map&lt;taskid, Task><br></li><li>更新逻辑 TaskManager::updata()<br></li><li>获取不同mtype(或sub_type)的任务<br></li><li>增加, 删除任务<br></li></ul></li></ol><h2 id=server-db>server&ndash;db
<a class=anchor href=#server-db>#</a></h2><p>通过MySQL Connector/C++ 连接mysql<br></p><h3 id=对外接口>对外接口
<a class=anchor href=#%e5%af%b9%e5%a4%96%e6%8e%a5%e5%8f%a3>#</a></h3><ul><li>void init()<br>创建work线程数量的db<br></li><li>shared_ptr&lt;db> get_db()<br>通过shared_ptr自带的计数use_count来确认db是否可用<br>mysql官方资料显示, mysqlx::Session非多线程安全.<br></li></ul><h3 id=参考资料>参考资料
<a class=anchor href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>#</a></h3><p><a href=https://dev.mysql.com/doc/x-devapi-userguide/en/collections-as-relational-tables.html>官方用例</a><br><a href=https://dev.mysql.com/doc/dev/connector-cpp/latest/group__devapi.html>API接口</a><br></p><h2 id=server-room>server&ndash;room
<a class=anchor href=#server-room>#</a></h2><h3 id=对外接口>对外接口
<a class=anchor href=#%e5%af%b9%e5%a4%96%e6%8e%a5%e5%8f%a3>#</a></h3><ul><li>GetTable 获取table状态信息<br></li><li>GetTableUser 获取玩家是否在桌子上<br></li><li>EnterTable(uid, tableid) 进入桌子<br></li><li>EnterTable(uid, tagRoomrule) 进入桌子<br></li><li>EnterTable(vector&lt;uid>, tagRoomrule) 进入桌子<br></li></ul><h3 id=table设计思路>table设计思路
<a class=anchor href=#table%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af>#</a></h3><p>roomSvr中的table是最基本的table, 不考虑金币场, 比赛场, 俱乐部<br>只处理游戏逻辑<br></p><p>也就是说, 这里Table不区分房卡场, 金币场等<br>对自身影响范围:<br></p><ol><li><input checked disabled type=checkbox> 门票的问题<br>门票无需特意处理, 因为在创建房间之前, 门票就已经算清楚了<br></li><li><input checked disabled type=checkbox> 算分的问题<br>只是把结果放出来, 至于具体如何处理, table可以不需要关心<br></li></ol><h3 id=战绩-and-and-录像回放>战绩 && 录像回放
<a class=anchor href=#%e6%88%98%e7%bb%a9-and-and-%e5%bd%95%e5%83%8f%e5%9b%9e%e6%94%be>#</a></h3><h4 id=查询>查询
<a class=anchor href=#%e6%9f%a5%e8%af%a2>#</a></h4><p>数据存放在database中<br>player_score 战绩-玩家信息<br>table_record 战绩-桌子信息<br>table_video 录像回放<br></p><p>模拟运行:<br></p><ol><li><p>查看大局战绩<br></p><pre><code class=language-text>player_score与table_record联查, onlyid为连接标志
根据player_score.userid 与 table_record.clubid 找出top 100的onlyid
根据onlyid和curcount=0 在player_score中查找所有符合条件的数据
最后联查player, 联查标记为userid
</code></pre></li><li><p>查看小局战绩<br></p><pre><code class=language-text>根据onlyid 在player_score查找即可
最后联查player, 联查标志位userid
</code></pre></li><li><p>查看录像回放<br></p><pre><code class=language-text>根据onlyid, curcount 在table_video中查找即可
</code></pre></li></ol><h4 id=录像回放-写入>录像回放 写入
<a class=anchor href=#%e5%bd%95%e5%83%8f%e5%9b%9e%e6%94%be-%e5%86%99%e5%85%a5>#</a></h4><ol><li><p>RoomServer frmae中处理, 子游戏不需要考虑<br></p></li><li><p>frame的SendTable()函数中, 调用录像类记录<br></p></li><li><p>在小局结束的时候, 调用录像类获取数据<br></p><pre><code class=language-text>这里的数据是proto序列化为string后, 又转为了raw-string, 方便写入数据库
</code></pre></li><li><p>数据库读取出raw-string, 转为string, 再转为录像数据table_video结构体<br></p></li><li><p>子游戏只需要解析table_video即可<br></p></li></ol><h3 id=小局结束-数据处理>小局结束 数据处理
<a class=anchor href=#%e5%b0%8f%e5%b1%80%e7%bb%93%e6%9d%9f-%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86>#</a></h3><ol><li><input checked disabled type=checkbox> 玩家 门票<br></li><li><input checked disabled type=checkbox> 玩家 财富变更<br></li><li><input checked disabled type=checkbox> 玩家 具体输赢情况<br></li><li><input checked disabled type=checkbox> 玩家 任务系统<br></li><li><input checked disabled type=checkbox> 桌子 战绩<br></li><li><input checked disabled type=checkbox> 桌子 回放<br></li></ol><p>财富变更表 &ndash; 比较独立的表格 player_log_treasure<br></p><table><thead><tr><th>玩家id</th><th>财富类型</th><th>财富数量</th><th>备注说明</th><th>插入时间</th></tr></thead></table><p>玩家输赢情况表 player_score<br></p><table><thead><tr><th>玩家id</th><th>当前桌子局数</th><th>椅子位置</th><th>分数</th><th>大赢家标志</th><th>唯一标志</th><th>插入时间</th></tr></thead></table><p>战绩表 table_record<br></p><table><thead><tr><th>桌子ID</th><th>桌子类型(房卡, 金币)</th><th>总局数</th><th>桌子玩家数</th><th>KindID</th><th>clubid</th><th>子游戏信息</th><th>唯一标志</th><th>插入时间</th></tr></thead></table><p>战绩回放表 table_video<br></p><table><thead><tr><th>当前桌子局数</th><th>回放数据</th><th>唯一标志</th><th>插入时间</th></tr></thead></table><p>备注说明:<br></p><ol><li>玩家财富变更均通过 玩家财富变更记录表 &ndash; 所有财富类型<br></li><li>战绩表 只 记录桌子信息, 而不记录 玩家输赢信息<br></li></ol><h3 id=玩家动作-坐下-起立-离开-解散-换桌--金币场>玩家动作 坐下|起立|离开|解散|换桌(金币场)
<a class=anchor href=#%e7%8e%a9%e5%ae%b6%e5%8a%a8%e4%bd%9c-%e5%9d%90%e4%b8%8b-%e8%b5%b7%e7%ab%8b-%e7%a6%bb%e5%bc%80-%e8%a7%a3%e6%95%a3-%e6%8d%a2%e6%a1%8c--%e9%87%91%e5%b8%81%e5%9c%ba>#</a></h3><p>玩家加入<br>玩家坐下<br>玩家起立<br>玩家离开<br>金币换桌<br></p><h4 id=旁观的处理>旁观的处理
<a class=anchor href=#%e6%97%81%e8%a7%82%e7%9a%84%e5%a4%84%e7%90%86>#</a></h4><pre><code class=language-text>是否旁观是由服务器根据桌子状态来判断的
</code></pre><p>玩家加入房间的时候<br>如果房间已经开始&&允许旁观, 则可以设置为旁观状态<br>如果房间没有开始, 则是坐下状态<br></p><h3 id=玩家状态>玩家状态
<a class=anchor href=#%e7%8e%a9%e5%ae%b6%e7%8a%b6%e6%80%81>#</a></h3><p>状态1 UserStatusL<br>状态2 UserStatusH<br></p><pre><code class=language-text>两者非互斥关系, UsetStatusL内部为互斥关系, UserStatusH内部为互斥关系
掉线之后未必为托管状态, 掉线8s之后, 将由掉线状态变为托管状态; 当掉线回来后, 托管状态自动取消
</code></pre><pre><code class=language-text>//用户状态 low
enum UserStatusL
{
   FREE_L=0;      //没有状态
   SIT = 1;       //坐下
   STANDUP =2;    //站立(旁观)
   READY= 3;      //准备状态
   PLAYING=4;     //游戏中
};
//用户状态 high 与low不互斥
enum UserStatusH
{
   FREE_H =0;     //正常状态
   TUOGUAN =1;    //托管
   OFFLINE=2;     //掉线 -- 掉线8s之后设置为托管状态
};
</code></pre><h3 id=椅子视图>椅子视图
<a class=anchor href=#%e6%a4%85%e5%ad%90%e8%a7%86%e5%9b%be>#</a></h3><p>唯一视图 真实的椅子位置<br>frame: m_player_list与真实椅子视图 是通过CPlayer来转换的<br>subgame: subgame实现了真实的椅子视图<br>client: client存在C视图 与 真实椅子视图(S视图)的转换<br></p><h3 id=tableid生成方式>tableid生成方式
<a class=anchor href=#tableid%e7%94%9f%e6%88%90%e6%96%b9%e5%bc%8f>#</a></h3><p>table 由redis启动的时候预先生成100000-999999<br>table_using使用zset记录tableid, 创建time. 后面删除的时候, 根据time来有选择的删除,<br>比如删除5分钟之前的桌子, 提高效率.<br></p><h3 id=房间配置加载>房间配置加载
<a class=anchor href=#%e6%88%bf%e9%97%b4%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd>#</a></h3><p>加载子游戏的fk, gold, match信息<br></p><h4 id=配置文件>配置文件
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h4><p>配置文件放在<br>kindid/cfg/kindid.fk<br>kindid/cfg/kindid.gold<br>kindid/cfg/kindid.match<br></p><h4 id=房间规则配置>房间规则配置
<a class=anchor href=#%e6%88%bf%e9%97%b4%e8%a7%84%e5%88%99%e9%85%8d%e7%bd%ae>#</a></h4><ul><li><p>房间规则分析</p><p><strong>房间规则由来</strong><br>对于每一个具体的游戏来讲, 游戏本身是规则下的流程<br>这里的规则分为两大类<br>一类是游戏自身的规则, 比如斗地主需要一副牌, 有三带一等各种牌型.<br>这种规则本身变化不大, 影响的是游戏自身的流程.<br>还有一类规则是影响游戏逻辑之外的, 比如3小局, 4小局. 比如这是房卡场的, 金币场的等等<br></p><p>于是我们把所有游戏共用的规则(主要是第二类规则), 提取出来放到tagRoomRuleCom<br>而对于每个子游戏不同的游戏规则, 我们只需要提供map&lt;key, choose_index>给子游戏即可<br></p><p>房间规则不区分游戏玩法.<br>房卡场, 金币场, 比赛场, 俱乐部玩法的房间规则使用同一个结构体tagRoomRule<br>通用房间规则 是指抽象出来供frame使用的, 使用统一结构体tagRoomRuleCom<br>子游戏规则 是每个子游戏自身的规则, 在frame层以map&lt;key, choose_index>的形式传递给子游戏, 由子游戏自己解析<br></p><p><strong>房间规则继续分析</strong><br>无论对于tagRoomRuleCom 还是map&lt;key, choose_index> 都可以认为是key, value的键值对<br>所以我们配置文件, 可以采取最基本的key, value形式.<br>但是考虑到房卡场, 金币场等具体玩法, 我们期待的金币场也可以配置自身的游戏规则.<br>比如初级场可以配置为3小局, 底分2; 中级场可以配置为2小局, 底分5;<br>因此可以再进一步抽象为<br></p><ol><li>先提供一个可供选择的规则配置<br></li><li>需要什么样的规则, 只要提供对应的choose, 就可以生成具体的tagRoomRule<br></li></ol></li></ul><ul><li><p>房间规则配置</p><p><strong>目标</strong><br></p><ol><li>金币场, 比赛场, 俱乐部模式 更好的配置游戏规则<br></li><li>对于房卡场, 服务器控制client的房间规则显示<br>client开发的时候 不需要做任何处理<br></li></ol><p><strong>client使用流程</strong><br></p><ol><li><p>client申请创建房间<br></p></li><li><p>server判断是否符合创建条件, 发送房间规则配置 rule_arry(在STR_Game.proto中)<br>其中css控制client显示的样式<br>rule表示一条规则<br></p><pre><code class=language-text>css
1
2
特殊规则 3, 4, 5

rule_1  人数
rule_2  局数
rule_3  炸弹
rule_4  鬼子
rule_5  天王九
</code></pre><pre><code class=language-text>人    数   &quot;2&quot; &quot;3&quot; &quot;4&quot;
局    数   &quot;2&quot; &quot;3&quot; &quot;4&quot;
特殊规则   炸弹o  鬼子o 天王九o
</code></pre></li><li><p>client返回 选择结果 repeated int32<br>比如: 上面选择了 2人 4局, 则返回<br>0<br>2<br>每个返回字段为byte, 返回的value index<br></p></li><li><p>server收到后, 构造房间规则tagRoomRule<br></p></li></ol><p><strong>其他游戏模式使用流程</strong><br>对于金币场,比赛场等使用更加简单, 直接提供choose_values即可<br></p></li></ul><h2 id=server-子游戏>server&ndash;子游戏
<a class=anchor href=#server-%e5%ad%90%e6%b8%b8%e6%88%8f>#</a></h2><ol><li>子游戏处理范围<br>游戏开始 &ndash; 大局结束<br></li><li>子游戏不涉及到玩家的财富<br>只会通知frame增减财富<br>client子游戏玩家财富信息的显示, 实际由frame控制, 而非子游戏<br></li></ol><h3 id=组织架构>组织架构
<a class=anchor href=#%e7%bb%84%e7%bb%87%e6%9e%b6%e6%9e%84>#</a></h3><p>FrameWork &ndash;> TableFrameSink &ndash;> GameData<br></p><p>备注: 1. tableFrameSink只是处理流程, 所有的数据都在GameData中<br></p><ol><li>CGameCardConfig 是GameData的辅助类.<br></li></ol><h3 id=牌类数据描述>牌类数据描述
<a class=anchor href=#%e7%89%8c%e7%b1%bb%e6%95%b0%e6%8d%ae%e6%8f%8f%e8%bf%b0>#</a></h3><p>玩家 使用16位表示<br>高四位 表示 玩家类型的ID &ndash; 比如 地主, 农民<br>再四位 表示 玩家数量<br>低8位 表示 玩家手牌数量<br></p><p>牌使用16位表示<br>高四位 表示 卡牌点数<br>中四位 表示 卡牌颜色<br>低8位 表示 卡牌类型组 &ndash; groupID, 配置文件挂钩<br></p><p>1方块; 2梅花; 3红桃; 4黑桃; 5表示特殊牌, 比如大王小王<br>大王小王 花色为5， 值分别为 15 14<br></p><h3 id=protobuf结构>protobuf结构
<a class=anchor href=#protobuf%e7%bb%93%e6%9e%84>#</a></h3><ol><li>消息号<br></li><li>游戏状态 (抢庄, 下注, 发牌 &mldr;.) &ndash; 断线重连相关<br></li><li>自定义enum, 比如牌型, 定时器等<br></li><li>消息号对应的结构体<br></li><li>断线重连对应的结构体 &ndash; 与游戏状态一一对应<br></li><li>战绩中 显示的子游戏信息<br></li></ol><h2 id=redis>redis
<a class=anchor href=#redis>#</a></h2><h3 id=已使用字段>已使用字段
<a class=anchor href=#%e5%b7%b2%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5>#</a></h3><table><thead><tr><th>含义</th><th>key</th><th>val</th><th>val_type_in_redis</th><th>场景</th><th>备注</th></tr></thead><tbody><tr><td>玩家信息</td><td>player_$uid</td><td>tagUserInfo</td><td>string</td><td>数据库与svr缓存</td><td>暂时未使用</td></tr><tr><td>排行榜</td><td>rank_$rankid</td><td>zset&lt;uid,score></td><td>ordered_set</td><td>rank data</td><td></td></tr><tr><td>排行榜过期时间</td><td>rank_$rankid_expire</td><td>int64_t</td><td>string</td><td></td><td>毫秒</td></tr><tr><td>玩家任务状态</td><td>task_status_$uid_$taskid</td><td>tagTaskstatus</td><td>string</td><td>task data</td><td></td></tr><tr><td>uggr索引</td><td>gate_$uid</td><td>gatesvr_id</td><td>string</td><td>uid在哪个gateSvr</td><td>不含机器人</td></tr><tr><td></td><td></td><td></td><td></td><td>玩家在多个gateSvr重复登陆时候, 校验</td><td>暂时未使用</td></tr><tr><td>uggr索引</td><td>room_$uid</td><td>roomsvr_id</td><td>string</td><td>uid在哪个roomSvr</td><td>不含机器人</td></tr><tr><td></td><td></td><td></td><td></td><td>只在uid登陆gate时候, gate用来记录map&lt;uid, room></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>后续map&lt;uid, room> 通过roomSvr主动通知gate</td><td></td></tr><tr><td>可用桌子号</td><td>table</td><td>set&lt;tableid></td><td>unordered_set</td><td></td><td></td></tr><tr><td>已用桌子号</td><td>table_using</td><td>zset&lt;tableid, time></td><td>unordered_set</td><td></td><td></td></tr><tr><td>已用桌子号</td><td>table_using_$tableid</td><td>$severid_$kindid</td><td>string</td><td>gateSvr用来查询tableid在哪个server上面</td><td></td></tr></tbody></table><h3 id=已使用lock字段>已使用lock字段
<a class=anchor href=#%e5%b7%b2%e4%bd%bf%e7%94%a8lock%e5%ad%97%e6%ae%b5>#</a></h3><table><thead><tr><th>含义</th><th>key</th><th>备注</th></tr></thead><tbody><tr><td>玩家信息锁</td><td>lock_player_$uid</td><td></td></tr></tbody></table><h2 id=server-redis><span class="org-todo todo TODO">TODO</span> server&ndash;redis
<a class=anchor href=#server-redis>#</a></h2><p>redis 控制服务<br></p><ol><li>初始化redis<br></li><li>redis中机器人对回收等<br></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#约定俗称>约定俗称</a><ul><li></li></ul></li><li><a href=#server-gate>server-gate</a><ul><li><a href=#logon>logon</a></li><li><a href=#game>game</a></li><li><a href=#center>center</a></li><li><a href=#server-match><span class="org-todo todo TODO">TODO</span> server&ndash;match</a></li><li><a href=#server-rank><span class="org-todo todo TODO">TODO</span> server&ndash;rank</a></li><li><a href=#server-task>server&ndash;task</a></li></ul></li><li><a href=#server-db>server&ndash;db</a><ul><li><a href=#对外接口>对外接口</a></li><li><a href=#参考资料>参考资料</a></li></ul></li><li><a href=#server-room>server&ndash;room</a><ul><li><a href=#对外接口>对外接口</a></li><li><a href=#table设计思路>table设计思路</a></li><li><a href=#战绩-and-and-录像回放>战绩 && 录像回放</a></li><li><a href=#小局结束-数据处理>小局结束 数据处理</a></li><li><a href=#玩家动作-坐下-起立-离开-解散-换桌--金币场>玩家动作 坐下|起立|离开|解散|换桌(金币场)</a></li><li><a href=#玩家状态>玩家状态</a></li><li><a href=#椅子视图>椅子视图</a></li><li><a href=#tableid生成方式>tableid生成方式</a></li><li><a href=#房间配置加载>房间配置加载</a></li></ul></li><li><a href=#server-子游戏>server&ndash;子游戏</a><ul><li><a href=#组织架构>组织架构</a></li><li><a href=#牌类数据描述>牌类数据描述</a></li><li><a href=#protobuf结构>protobuf结构</a></li></ul></li><li><a href=#redis>redis</a><ul><li><a href=#已使用字段>已使用字段</a></li><li><a href=#已使用lock字段>已使用lock字段</a></li></ul></li><li><a href=#server-redis><span class="org-todo todo TODO">TODO</span> server&ndash;redis</a></li></ul></nav></div></aside></main></body></html>