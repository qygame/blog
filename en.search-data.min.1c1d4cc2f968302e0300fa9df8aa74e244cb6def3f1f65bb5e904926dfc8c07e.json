[{"id":0,"href":"/blog/docs/client/sdk/bdframework/","title":"BDFramework","section":"sdk介绍","content":" client BDFramework # 框架ui学习 # ScereenView : IScereenView \u0026ndash; ScreenViewManager.Inst.MainLayer.BeginNavTo(ScreenViewEnum.Main); \u0026ndash; ui1 : AWindow \u0026ndash; UIManager.Inst.LoadWindow( WinEnum.Win_Demo1); \u0026ndash; ui2 \u0026ndash; UIManager.Inst.ShowWindow(WinEnum.Win_Demo1); \u0026ndash; button 根据[TransformPath(\u0026ldquo;Button\u0026rdquo;)] 直接获取 脚本学习 # 配置脚本 Config [代码路径], [sqlite路径], [资源路径] 之外, 其他暂时没用 title 说明 备注 代码路径 Sqlite路径 资源路径 s 配置到其他路径 资源路径 仅StreamAsset下生效 Code Run Mode 运行模式 Edit不生效 文件服务器 GameConfig的下载路径 GameConfig即Config配置文件 Gate服务器 无用 port 无用 是否热更 无用 是否联网 无用 本地配置 GameConfig本地配置路径 热更脚本 VersionContorller 步骤: BDtools -\u0026gt; 资源一键打包 -\u0026gt; 一键导出 DBtools -\u0026gt; 资源一键打包 -\u0026gt; 热更资源转Hash 找到{platform}Hash目录, 放到服务器, 并移除目录中的_Hash 记录改地址, 比如 https://sss.com/StreamAsset StreamAsset的下一次目录即是{platform} 调用热更脚本下载 下载的时候 url 应该指定到StreamAsset目录 注意事项 # 主工程不写enum 主工程 不调用 热更代码 热更工程 不继承主工程 跨域继承 写 adotor 反射 需要写 绑定 update() 只能在主工程中调用 使用[TransformPath(\u0026ldquo;xx\u0026rdquo;)] 寻找对象的时候, 不能使用GameObject, 应该使用具体的类型 错误实例: [TransformPath(\u0026quot;navigate_panel/btn_main\u0026quot;)] private GameObject btn_main; //主页 正确实例 [TransformPath(\u0026quot;navigate_panel/btn_main\u0026quot;)] private UIButton btn_main; //主页 sub window 不会调用Init 函数 直接在构造函数中处理即可 frame根据SubEnum加载子游戏, 加载成功后, 子游戏自动生成agenda向GameApp.GameManager注册 子游戏继承PokerGameAgent的对象名字必须为GameEngine 代码优化 # 音频资源加载之后, 切换SceneView时候, 如何卸载不需要的音频资源 未热更部分 # 音频管理类 MyListener继承了UIEventListener 而MyListener中调用了音频管理类 以后放到 热更代码中 "},{"id":1,"href":"/blog/docs/client/build/build/","title":"unity打包注意事项","section":"打包流程","content":" unity打包ios 注意事项 # 修改ShareSDK社交平台列表 Assets/Plugins/ShareSDK/ShareSDK.cs修改 ShareSDK认证 Assets/Plugins/ShareSDK/ShareSDKDevInfo.cs修改 微信资质认证 修改后, 需要在unity场景中Reset一下ShareSDK.CS脚本 Unity Build-Setting中 替换logo Unity Build-Setting中 替换包名 unit打包android注意事项 # Assets/Plugins/Android/AndroidManifest.xml中修改 包名, ShareSDK认证, 微信回调包名 Unity Build-Setting中 替换logo Unity Build-Setting中 替换包名 "},{"id":2,"href":"/blog/docs/client/base/unity/","title":"unity","section":"unity, android, ios基础","content":" scene view 中 # 2个手指按压 2D移动; 3D旋转 2个手指滑动 缩放 alt+f 模拟game视图 ctrl 显示尺寸大小? 点击hierarcht中的物体, 按F 可以使视图居中在该物体 移动的物体 按 shitf+F可以锁定 hierarchy 中 # alt + 点击可以切换所有子child(递归) 的显示与隐藏 其他 # unity会完全忽略以 ~ 结尾的文件或目录 "},{"id":3,"href":"/blog/docs/client/sdk/sharesdk/","title":"ShareSDK","section":"sdk介绍","content":" shareSDK指导文档 # 基本说明 # shareSDK是第三方插件(如果把微信,QQ等比作第一方), 其集成了很多平台, 可以实现快速接入 操作步骤 # 在官网下载对应的SDK包 包里面有Android工程 和 U3D(如果sdk是针对u3d)工程 编译Android工程, 为自己的U3D工程添加插件 Android工程的编译目标是U3D的插件 在自己的U3D工程中 导入并修改官方的u3d Demo 完成 F\u0026amp;Q # 问: 官方的android工程打不开? 答: 根据不同的IDE, 有不同注意事项 Eclisp IDE的时候, compiler和jdk版本要匹配 Android stutio, 需要将工程import import 官方的android工程是Eclisp的, 需要转换 问: Android Stutio如何编译官方的android工程? 答: Android Stutio编译的时候需要有以下几个注意点 编译器gradlew版本 修改工程下gradle/wrapper/gradle-wrapper.properties文件中的distributionUrl版本为4.1 修改工程下build.gradle文件中的classpath版本为4.1 \u0026ndash; 只影响gradlew指令, 不修改也可以 app文件的taget从app改为android module 修改工程下app/built.gradle文件中的plugin为apply plugin: \u0026lsquo;com.android.library\u0026rsquo; 删除工程下app/built.gradle文件中的applicationId \u0026ndash; 仅当application才有 app文件的taget sdk版本修改 修改工程下app/built.gradle文件中的compileSdkVersion和targetSdkVersion为21 (与安装的sdk版本匹配) 修改工程下app/src/main/AndroidManifest.xml中的targetSdkVersion为21 以上的sdk版本 应当与u3d编译时的选项一致 app文件依赖性修改 修改工程下app/built.gradle文件中的dependence为implementation 具体原因, 详见Android Stutio的六种编译方式 包名的修改 修改工程下app/src/main/Androidmanifest.xml中的manifest包名为your包名 修改工程下app/scr/main/assets/SharSDK.xml中的微信认证资质 修改工程下app/src/main/java/cn/share/demo下的所有文件的包名前缀替换为your包名 \u0026ndash; 不需要修改目录名字 认证资质的修改 修改工程下app/src/main/Androidmanifest.xml中application字段中的Mob-AppKey和Mob-AppSecret为自己的 rebuilt-project 完成 其余的东西无需改动； 生成的aar包在工程下app/build/outputs/aar/app-debug.aar； 生成的jar包在工程下app/build/intermidiates/bundles/debug/classes.jar 问: 自己的U3D工程如何与官方demo结合编译? 答: 自己的U3D工程编译有以下几个注意点 shareSDK插件的导入 双击官方U3D工程中的ShareSDKForU3D.unitypackage (其实际就是将官方U3D工程下的Assets/Plugins导入到自己的U3D下) 不要导入demo.cs和ShareSDK-Unity.unity以及Plugins/Android/ShareSDK/DemoCallback.jar 导入的时候需要注意路径问题, 比如正常的是Pligins/Android/ShareSDK/xml | libs | res, 千万不能写作Plugins/Android/xml 否则, 会导致自己U3D工程打包后没有图像\u0026hellip;因为路径错了 建议先删除自己的Plugins目录, 然后执行动作1)， 然后再将自己差异化的插件导入(注: 将android studio工程中lib下的jar包全部导入) 将Android工程生成的classes.jar改名为com.quyou.tielinmajang.jar并copy到自己U3D工程下的Plugins/Android/ShareSDK/libs/ 将Android工程下AndroidManifest.xmlcopy到自己U3D工程下的Plugins/Android/ShareSDK/ 修改资质认证 Plugins/ShareSDK/ConstDefine.h 文件中 官方的资质认证 Plugins/ShareSDK/ShareSDK.cs 有1处。 位置在成员变量处 Plugins/ShareSDK/ShareSDKConfig.cs 有1处。 位置在Config函数中 微信登录的资质认证 Plugins/ShareSDK/ShareSDKDevInfo.cs 有1处。 位置在微信登录的函数中 选择使用平台 修改 Plugins/ShareSDK/ShareSDKDevInfo.cs 的成员变量。 不需要的平台直接注释相应的成员变量即可 调用ShareSDK的脚本文件 官方的demo写的比较乱, 不推荐 高手可以自己写 可以直接使用之前的人写的 AuthAndShare.cs 将ShareSDK.cs和AuthAndShare.cs挂在控件上。 U3D基本功, 不详述, 只想吐槽 选择keyStore 编译。 完成 keystroe只影响签名 使用包名A,生成的apk其签名 应该与在微信开放平台上的包名A的签名一致 问题解答 问: U3D打包的时候出现 can\u0026rsquo;t convert class to index 答: jar包问题, 排查jar包的依赖型是否都存在， 执行问题3中的1)中的3) 大坑 # 分享的content中 image url必须存在， 无论本地还是远端 否则, 微信分享会调用失败 shareSDK的脚本中的 byPass Approve 必须去掉勾选 不勾选, 分享的webpage可能变为图片(应用信息) "},{"id":4,"href":"/blog/docs/client/base/android/","title":"Android","section":"unity, android, ios基础","content":" Java的一些基础 # Activity # Activity是 java中类的实例化 activity存在于一些堆栈中, 似于线程的操作 Activity必须在mainfest.xml中进行注册，才可以启动 oncreate \u0026ndash; onstart \u0026ndash; onresume \u0026ndash; stop activity有显示启动和隐式启动 AndroidMainFest.xml # 类似于activity管理器的配置文件 决定了哪个activity先启动， 决定了哪些activity可以启动 inter-filter决定了activity是否是main activity，也决定了activity在什么情形下可以隐式启动 "},{"id":5,"href":"/blog/docs/client/env_init/","title":"环境搭建","section":"client","content":" 环境搭建 # unity 2019.4.40f1 Windows Build Support(IL2CPP) 或 Mac Build Support(IL2CPP): HyCLR需要 vs2019 使用Unityd的游戏开发 HyCLR需要 工程搭建 # [X] 表示工程中已完成 [ ] 需要手动处理 BDFrameWork package 导入Asset资源到工程 导入Odin插件 BDFramework工具箱/框架配置 (各种打包设置) HyCLR 菜单栏 HyCLR \u0026ndash; install *安装完之后, 需要重启unity去生成HyCLR Setting ShareSDK generate sln BDFramework build hotfix.dll需要 Preferences/External Tools/Regenerate project files 需要勾选Embedded packages, Local packages, Registry packages 注意事项 # 第一次构建的时候, il2cpp需要编译整个工程(?), 因此速度会很慢很慢(差不多30多分钟) "},{"id":6,"href":"/blog/docs/client/build/build_apple/","title":"苹果打包流程","section":"打包流程","content":" 环境 # 工具 版本 备注 unity 2019.4.40f1 xcode 11.3 打包流程 # unity切换到ios平台 File→Build Setting→Run in Xcode as 选择Release unity build setting Player Seetings→Splash Image→Splash Screen→Show Splash Screen去掉勾选(需要破解unity) Player Settings→Other Setting→Target SDK选择Device SDK (真机) unity build xcode打开unity的build输出目录 Xcode选择右下角的Open another Project, 选择Unity发布出来的Xcode工程 或者双击打包好的工程的.xcodeproj文件 如果工程中没有SDK则需要手动添加最新SDK. 操作： 鼠标右键文件夹Unity-iPhone→Add Files to \u0026ldquo;Unity-iPhone\u0026rdquo;…​→选中SDK→Add 选择team TARGETS→Unity-iPhone→Signing \u0026amp; Capabilities→选择Team（使用已有ID登录） 修改Enable Bitcode TARGETS→Unity-iPhone→Build Settings-\u0026gt;build options-\u0026gt;Enable Bitcode修改为No 直接点击上方菜单栏Product → Build生成项目，successed 常见问题 # library not found for -lstdc.6.0.9 TARGETS-\u0026gt;Unity-iPhone-\u0026gt;Build Phases-\u0026gt;Link Binary with Libraries-\u0026gt;最底下+号-\u0026gt;添加libstdc++.6.0.9.tbd _res9getservers TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加libresolv.tbd文件 inflateEnd,referenced from \u0026ldquo;inflateInit\u0026rdquo; TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加libz.tbd文件 sqlite TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加libsqlite3.0.tbd文件 OBJCCLASS_$SKPaymentQueue\u0026quot; TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加StoreKit.framework OBJCCLASS_$WKWebView: TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加WebKit.framework _kUTTagClassFilenameExtension: TARGETS→Unity-iPhone→Build Phases→Link Binary with Libraries→最底下+号→添加MobileCoreServices.framework Xcode编译出现OBJCCLASS_$XX问题的解决方案 TARGETS→Unity-iPhone→Build setting→Linking→Other Linker Flags→将此属性修改成-allload 和 -Objc library not found for-liPhone-lib-Xcode整合Unity项目报错 进入Targets→Build Settings→Search Paths-\u0026gt;Library search paths中，把“\\(（SRCROOT）/Libraries”的双引号去掉，即改为\\)(SRCROOT)/Libraries就行了 苹果发包说明 # 个人 \u0026amp;\u0026amp; 企业 Ad-hoc 需要在开发者平台中添加目标设备的uuid, 重新打包, 提交到托管平台(比如蒲公英)分发 如果想别人可以使用 上架苹果商店 通过企业签名 \u0026ndash; 一般多为代签 通过Test Flight \u0026ndash; 还未测试 把别人的uuid添加进开发者平台中 \u0026ndash; 测试还可以, 正式发布不行 "},{"id":7,"href":"/blog/docs/client/subgame/","title":"子游戏","section":"client","content":" client子游戏 # 子游戏需要继承 Iwindow_sub_player 玩家管理类, 并注册UI GWin_Sub_Player 子游戏需要继承 Isub_player 玩家信息类 "},{"id":8,"href":"/blog/posts/client/","title":"Client","section":"Posts","content":" client # 脚本目录架构 # Scripts \u0026ndash; /Define 公共定义 \u0026ndash; \u0026ndash; GameRunTimeData.cs 保存了运行时候需要的数据, 比如UserInfo就是其的成员变量 \u0026ndash; \u0026ndash; GlobalConst.cs 保存了游戏中的常量 \u0026ndash; /Model 模块 \u0026ndash; /Net 网络 \u0026ndash; \u0026ndash; /NetLogic 网络具体事务处理 \u0026ndash; \u0026ndash; /NetSocket 网络底层服务 \u0026ndash; /UI \u0026ndash; \u0026ndash; /Surfaces \u0026ndash; \u0026ndash; /Login \u0026ndash; \u0026ndash; \u0026ndash; LoginTransfer.cs ui界面的总控制类， 其底下一般是各种btn的点击函数 \u0026ndash; \u0026ndash; \u0026ndash; BtnClick_Logon_Account.cs 账号登录按钮的 响应函数 \u0026ndash; /Utility 实用脚本， 可以理解为与系统相关的脚本 \u0026ndash; GameApp.cs Compontes目录下所有类的 管理类 断线重连 # 表1: socket断开, socket重新连接后, 需要完成的事情: socket 服务器 需求 备注 游戏服 1. ID登录 2. 如果在房间中, 进入子游戏场景, 获取房间信息 获取房间信息, 只需要完成[100.1]系列消息 3. 如果没有在房间中, 不处理 登录服 1. ID登录 表2: 断线重连情形 断线场景 哪个socket断线 重连情形 应该的处理事情 备注 login场景 登录服socket 关闭重开 ID登录 login场景 不存在此情形 Hall场景 登录服socket 关闭重开 登录服ID登录 Hall场景 登录服socket 后台切前台 登录服ID登录成功, 重复进入大厅场景, 需要处理 登录服ID登录失败, 进入子游戏场景 Hall场景 游戏服socket 关闭重开 登录服ID登录成功, 回到Hall初始页面, 不做之前window页面恢复 Hall场景 游戏服socket 后台切前台 游戏服ID登录 子游戏场景 登录服scoket 关闭重开 登录服ID登录成功, 在房间中, 游戏服socket连接,ID登录,进入子游戏场景,请求房间信息 登录服ID登录成功, 不在房间, 进入大厅场景 子游戏场景 登录服socket 后台切前台 登录服ID登录失败, 回到登录场景 登录服ID登录成功, 在房间中, 不处理 登录服ID登录成功, 不在房间, 进入大厅场景 子游戏场景 游戏服socket 关闭重开 登录服ID登录成功, 在房间中, 游戏服socket链接,ID登录,进入子游戏场景,请求房间信息 登录服ID登录成功, 不在房间, 进入大厅场景 子游戏场景 游戏服socket 后台切前台 游戏服ID登录成功, 在房间中, 请求房间信息 游戏服ID登录成功, 不在房间, 返回大厅 表3: 业务流程 socket服务器 流程 情形 登录服 socket连接成功后, 自动登录 1. 登录失败, 则返回登录场景 2. 登录成功, 如果在房间中(服务器判断), 则进入子游戏场景 3. 登录成功, 如果没在房间(服务器判断), 则进入大厅场景 游戏服 socket连接成功后, 自动登录 1. 登录失败, 提示错误 2. 登录成功, 则根据动作来具体判断 处理什么业务 根据表1写表2, 根据表2写表3 frame与子游戏热更分离 # frame热更 使用kindid =0 子游戏热更路径为kinid frame 进入子游戏的时候, 会先判断子游戏是否需要热更, 如果需要进行热更, 否则不处理 sub 开头的window 其层级为10, canvas, 其他均默认为0 # "},{"id":9,"href":"/blog/posts/readme/","title":"Readme","section":"Posts","content":" 简介 # 休闲游戏模板, 包含服务器, 客户端, 数据库和监控系统. 服务器运行在docker容器,支持docker-compose与k8s两种安装方式. 使用C++开发. 客户端使用unity平台, 使用C#开发. 数据库使用redis, mysql. 监控系统采用prometheus + grafana. 安装 # 下载开发环境. 包含了数据库, 游戏运行环境, redis等 git clone git@github.com:qydocker/docker-compose.git \u0026amp;\u0026amp; cd docker-compose ./build.sh dev *下载监控 (可选) git clone git@github.com:qydocker/docker-compose.git \u0026amp;\u0026amp; cd docker-compose ./build monitor 下载执行文件 git clone --branch 1.0.0 git@github.com:qygame/svr-publish.git \u0026amp;\u0026amp; cd svr-publish ./server.sh start 游戏功能 # 登陆模块 - 重复登陆，断线重连. 登陆方式支持: 账号密码，游客，微信等 房间列表显示模块 房卡场 创建界面 金币场 列表展示 房间创建流程 子游戏模块 房间结束后， 信息统计 大局战绩 小局战绩 录像回放 财富修改记录 任务模块 排行榜 比赛场 活动模块 工会 源码仓库 # 详细介绍 源码设计文档 # 服务器架构介绍 服务器源码介绍 客户端介绍 "},{"id":10,"href":"/blog/posts/repository/","title":"Repository","section":"Posts","content":" 构建流程 # qydocker与qygame协同工作, 构建docker images. 具体流程如下图: qydocker # 管理docker image. 负责image构建与运行. 托管在qydocker organization 仓库名 作用 qydocker/build_image_dev 构建qygame base image qydocker/build_publish 编译qygame, 结果托管在qygame/svr-publish qydocker/build_image 构建qygame images qydocker/docker-compose 使用docker-compose管理qygame images qydocker/k8s 使用k8s管理qygame images qydocker/mirror_google_image google docker镜像映射到dockerhub, 加快访问速度 qygame # 管理游戏源码, 主要有server端代码, client代码, protocol协议, database. 托管在qygame organization 仓库名 作用 备注 qygame/svr-kernel 业务与基础库的适配层 qygame/svr-frame 业务层 依赖svr-kernel qygame/svr-subgames 子游戏 依赖svr-frame qygame/protocol client与server消息协议 qygame/client client qygame/database 数据库 qygame/svr-publish 以branch形式存放svr编译结果 "},{"id":11,"href":"/blog/posts/server/","title":"Server","section":"Posts","content":" 约定俗称 # 消息号命名规范 # 为了client与server的统一, 消息号统一使用驼峰式命名, exp: SubQueryGoldRooms 第一个字段 归属标志 可能的赋值 Sub C端向S端查询 Cmd S端返回给C端 L2G logon-\u0026gt;Game G2L game-\u0026gt;logon 只有Lgon, game间的消息号使用 LG字样, 其他全部是Sub, Cmd 第二个字段 意图 增删改查 第三个字段 对象 被op对象 \u0026ndash; 可以没有 第四个字段 消息号含义 结构体的命名为 消息号前面增加Str 函数的命名为 消息号前面增加On 玩家的桌子号 # player.tableid 含义: 玩家在哪个桌子上 用途: 登录的时候 判断断线重连 进入table时的校验, 防止加入2张桌子 状态变化: roomSvr table加入|坐下, 设置为桌子的tableid roomSvr table离开, 如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE matchSvr 报名成功, 设置为MATCH_TABLE matchSvr 取消报名, 设置为INVALID_TABLE 房间流程 # 创建房间 \u0026ndash; 门票检测, 房间规则显示 RoomServer处理 房间规则使用rule_arry结构体传送给客户端显示 加入房间 \u0026ndash; 门票检测 GameServer处理 门票检测时 也会进行游戏资格检测 房间规则在子游戏的显示 RoomServer frame处理 frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息 玩家信息在子游戏的显示 RoomServer frame处理 玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client client根据动作, 判断是绘制还是删除玩家 玩家财富变更后, LogonServer会通知client, 更改大厅的显示 如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示 即SubGame子游戏不再提供玩家分数相关信息给client 游戏开始|一小局后 \u0026ndash; 门票扣除 RoomServer frame处理 门票扣除信息 在RoomRuleCom中, 由GameServer生成 每小局游戏结束 \u0026ndash; 游戏小局结算 RoomServer frame处理 小局结算写分 战绩记录 录像回放 每局游戏结束后 \u0026ndash; 游戏资格检测 RoomServer frame处理 数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理 server-gate # logon # 重复登陆 # 在当前gateSvr中重复登陆 auto player = player_manager.get(uid); player.gatesvr_session != player.current_session 就认为是重复登陆 在所有gateSvr中重复登陆 redis中存在 key=gate_$uid, val=gatesvrid redis.val != current_serverid 说明该uid正在其他gateSvr上. 认为重复登陆 重复登陆处理 在当前gateSvr中重复登陆, 可以直接关闭旧的连接 在其他gateSvr中重复登陆, 需要通过 ?? 通知对应的gateSvr, 关闭玩家连接 断线重连 # 判断依据 玩家登陆的时候, redis中存在 key=room_$uid, val=roomsvrid gateSvr会向roomSvr确认玩家是否真的在roomSvr中, 如果roomSvr返回在, 则认为玩家是断线重连 断线处理 gateSvr更新player的roomsvrid信息 通知client game # 房间信息查询 数据来源于roomSvr. roomSvr连接成功之后, 会主动推送 数据格式 # 房卡场 \u0026ndash; 查询房间配置: file: cfg_fk.hh data: map\u0026lt;kindid, rule_arry\u0026gt; 金币场 \u0026ndash; 查询金币场信息 file: cfg_gold.hh data: map\u0026lt;kindid, vector\u0026lt;gold_msg\u0026gt;\u0026gt; roomSvr信息 file: server_manager data: map\u0026lt;session, vec\u0026lt;kind+level\u0026gt;\u0026gt; map\u0026lt;vec\u0026lt;kind+level\u0026gt;, session\u0026gt; 保留roomSvr的意义: 如果roomSvr与gateSvr断开连接了, 那么就可以实时的更新3个data数据. 保证client那边看到的永远是可用的服务器 center # 路由clien \u0026lt;-\u0026gt;roomSvr client -\u0026gt; gate -\u0026gt; roomsvr 依据\u0026lt;player, roomsvrid\u0026gt; \u0026lt;x_session, roomsvrid\u0026gt;路由 不使用redis的room_$uid是因为redis承载量不够 roomsvr -\u0026gt; gate -\u0026gt; client 依据\u0026lt;player, client_session\u0026gt;路由 \u0026lt;player, roomsvrid\u0026gt; 在player_manager中维护 玩家登陆成功时候, 根据redis中room_$uid来确认 玩家在roomSvr中加入或退出的时候, roomSvr也会主动推送给gateSvr. \u0026lt;x_session, roomsvrid\u0026gt; 在server_manager中维护 对外接口 # SetRoomID(uid, roomsvrid) TODO server\u0026ndash;match # 设计理念 # matchSvr负责维护 {uid, score} 排行, 具体的数据是roomSvr通知的matchSvr match没有必要把同排行的人放到一个roomSvr, 因此不需要指定roomSvr 组织架构 # kind1 -- match-type 1 -- match 1 -- {对应一系列桌子} -- .... -- match N -- .... -- match-type N .... kind N 流程 # 玩家申请加入某个比赛场match_type, 如果没有空的match, 则创建一个match, 放入玩家 设置其tableid为MATCH_TABLE, 防止进入其他桌子 如果玩家取消比赛, tableid重置为INVALID_TABLE 玩家掉线的时候, 如果还在比赛排队状态(tableid为MATCH_TABLE), 则按取消比赛处理 当match满足触发条件之后, 开始比赛 matchSvr把玩家分组, 并通知roomSvr创建桌子 roomSvr进行游戏, 当table大局结束的时候, 把数据(score)返回给matchSvr matchSvr进行排序, 重新分组, 继续通知roomSvr开始游戏 循环直至比赛结束为止 依赖关系 # 依赖GameSvr, 需要GameSvr提供的GetRoomRule()接口 缺陷 # 有状态的, 需要后期改为无状态服务器 配置文件 # 配置文件放在subgames/kinid/kindid.match中 TODO server\u0026ndash;rank # 对外接口 # PushRank(ranktype, uid, score) 配置文件 # 配置文件放在database rank表 id rank_name rank_desc type sortid award valid 自增 名字 描述 类型(唯一标志) 优先级 奖励 是否开启 定时功能的设计 # 自定义定时操作 缺点非常明显, 如果Svr挂了, 那么可能会导致数据错乱 所以需要额外考虑svr挂掉的情况 server\u0026ndash;task # 对外接口 # PushTask(task_type, uid, score) 流程图 # +--------+ | start | +--------+ | | v +--------+ 否 | 触发 |------------+ +--------+ | 是| | | | v | +--------+ 否 | | 完成 | -----+ | +--------+ | | | | | 是 | | | v | | +--------+ | | | updata | \u0026lt;----+ | +--------+ | | | +---v----+ | | end | \u0026lt;----------+ +--------+ 触发条件判断 时间start - end范围 特定kind, 特定room_level下的任务. 比如完成斗地主高级场一次 用户身份的限定 比如vip才可完成的任务 完成条件的判断 需要先根据周期重置来重置任务完成状况 任务完成状况与task配置中的任务step_all比较, 判断是否完成 update 更新任务完成状况 配置文件 \u0026amp;\u0026amp; 中间状态 # 配置文件放到database task表 名称 描述 类型 优先级 开始时间 结束时间 重置周期 其他触发限制 总步数 奖励配置 name desc type priority start_time end_time reset_period on_xml step_all award type解释, 斗地主初级场1次, 斗地主初级场2次, 斗地主初级场3次 那么他们的type可以一致, 并设置priority分别为1,2,3 这样就可以认为这三个任务是阶段性任务. 先完成斗地主初级场1次后, 才会显示斗地主初级场2次; 完成斗地主初级场2次后,才会显示斗地主初级场3次. 形成一个阶段 所以type相同, 认为是同一种类型任务(触发流程, 完成流程都一致), 而priority可以区分其阶段. 中间状态放到redis task_status_$uid_$taskid表 uid 任务id 当前步数 任务完成时间 任务状态 uid taskid step_current time status time应该是任务完成的时间. 昨天完成的时间, 到了今天也会重置 status 0 未完成, 1完成未领奖, 2完成已领奖 任务类的设计 # Task tagTask 任务配置的数据结构 触发逻辑判断 task::bOn(\u0026hellip;) 入参可能较多 完成逻辑判断 task::bComplete(tagTaskStatus) TaskManager map\u0026lt;taskid, Task\u0026gt; 更新逻辑 TaskManager::updata() 获取不同mtype(或sub_type)的任务 增加, 删除任务 server\u0026ndash;db # 通过MySQL Connector/C++ 连接mysql 对外接口 # void init() 创建work线程数量的db shared_ptr\u0026lt;db\u0026gt; get_db() 通过shared_ptr自带的计数use_count来确认db是否可用 mysql官方资料显示, mysqlx::Session非多线程安全. 参考资料 # 官方用例 API接口 server\u0026ndash;room # 对外接口 # GetTable 获取table状态信息 GetTableUser 获取玩家是否在桌子上 EnterTable(uid, tableid) 进入桌子 EnterTable(uid, tagRoomrule) 进入桌子 EnterTable(vector\u0026lt;uid\u0026gt;, tagRoomrule) 进入桌子 table设计思路 # roomSvr中的table是最基本的table, 不考虑金币场, 比赛场, 俱乐部 只处理游戏逻辑 也就是说, 这里Table不区分房卡场, 金币场等 对自身影响范围: 门票的问题 门票无需特意处理, 因为在创建房间之前, 门票就已经算清楚了 算分的问题 只是把结果放出来, 至于具体如何处理, table可以不需要关心 战绩 \u0026amp;\u0026amp; 录像回放 # 查询 # 数据存放在database中 player_score 战绩-玩家信息 table_record 战绩-桌子信息 table_video 录像回放 模拟运行: 查看大局战绩 player_score与table_record联查, onlyid为连接标志 根据player_score.userid 与 table_record.clubid 找出top 100的onlyid 根据onlyid和curcount=0 在player_score中查找所有符合条件的数据 最后联查player, 联查标记为userid 查看小局战绩 根据onlyid 在player_score查找即可 最后联查player, 联查标志位userid 查看录像回放 根据onlyid, curcount 在table_video中查找即可 录像回放 写入 # RoomServer frmae中处理, 子游戏不需要考虑 frame的SendTable()函数中, 调用录像类记录 在小局结束的时候, 调用录像类获取数据 这里的数据是proto序列化为string后, 又转为了raw-string, 方便写入数据库 数据库读取出raw-string, 转为string, 再转为录像数据table_video结构体 子游戏只需要解析table_video即可 小局结束 数据处理 # 玩家 门票 玩家 财富变更 玩家 具体输赢情况 玩家 任务系统 桌子 战绩 桌子 回放 财富变更表 \u0026ndash; 比较独立的表格 player_log_treasure 玩家id 财富类型 财富数量 备注说明 插入时间 玩家输赢情况表 player_score 玩家id 当前桌子局数 椅子位置 分数 大赢家标志 唯一标志 插入时间 战绩表 table_record 桌子ID 桌子类型(房卡, 金币) 总局数 桌子玩家数 KindID clubid 子游戏信息 唯一标志 插入时间 战绩回放表 table_video 当前桌子局数 回放数据 唯一标志 插入时间 备注说明: 玩家财富变更均通过 玩家财富变更记录表 \u0026ndash; 所有财富类型 战绩表 只 记录桌子信息, 而不记录 玩家输赢信息 玩家动作 坐下|起立|离开|解散|换桌(金币场) # 玩家加入 玩家坐下 玩家起立 玩家离开 金币换桌 旁观的处理 # 是否旁观是由服务器根据桌子状态来判断的 玩家加入房间的时候 如果房间已经开始\u0026amp;\u0026amp;允许旁观, 则可以设置为旁观状态 如果房间没有开始, 则是坐下状态 玩家状态 # 状态1 UserStatusL 状态2 UserStatusH 两者非互斥关系, UsetStatusL内部为互斥关系, UserStatusH内部为互斥关系 掉线之后未必为托管状态, 掉线8s之后, 将由掉线状态变为托管状态; 当掉线回来后, 托管状态自动取消 //用户状态 low enum UserStatusL { FREE_L=0; //没有状态 SIT = 1; //坐下 STANDUP =2; //站立(旁观) READY= 3; //准备状态 PLAYING=4; //游戏中 }; //用户状态 high 与low不互斥 enum UserStatusH { FREE_H =0; //正常状态 TUOGUAN =1; //托管 OFFLINE=2; //掉线 -- 掉线8s之后设置为托管状态 }; 椅子视图 # 唯一视图 真实的椅子位置 frame: m_player_list与真实椅子视图 是通过CPlayer来转换的 subgame: subgame实现了真实的椅子视图 client: client存在C视图 与 真实椅子视图(S视图)的转换 tableid生成方式 # table 由redis启动的时候预先生成100000-999999 table_using使用zset记录tableid, 创建time. 后面删除的时候, 根据time来有选择的删除, 比如删除5分钟之前的桌子, 提高效率. 房间配置加载 # 加载子游戏的fk, gold, match信息 配置文件 # 配置文件放在 kindid/cfg/kindid.fk kindid/cfg/kindid.gold kindid/cfg/kindid.match 房间规则配置 # 房间规则分析\n房间规则由来 对于每一个具体的游戏来讲, 游戏本身是规则下的流程 这里的规则分为两大类 一类是游戏自身的规则, 比如斗地主需要一副牌, 有三带一等各种牌型. 这种规则本身变化不大, 影响的是游戏自身的流程. 还有一类规则是影响游戏逻辑之外的, 比如3小局, 4小局. 比如这是房卡场的, 金币场的等等 于是我们把所有游戏共用的规则(主要是第二类规则), 提取出来放到tagRoomRuleCom 而对于每个子游戏不同的游戏规则, 我们只需要提供map\u0026lt;key, choose_index\u0026gt;给子游戏即可 房间规则不区分游戏玩法. 房卡场, 金币场, 比赛场, 俱乐部玩法的房间规则使用同一个结构体tagRoomRule 通用房间规则 是指抽象出来供frame使用的, 使用统一结构体tagRoomRuleCom 子游戏规则 是每个子游戏自身的规则, 在frame层以map\u0026lt;key, choose_index\u0026gt;的形式传递给子游戏, 由子游戏自己解析 房间规则继续分析 无论对于tagRoomRuleCom 还是map\u0026lt;key, choose_index\u0026gt; 都可以认为是key, value的键值对 所以我们配置文件, 可以采取最基本的key, value形式. 但是考虑到房卡场, 金币场等具体玩法, 我们期待的金币场也可以配置自身的游戏规则. 比如初级场可以配置为3小局, 底分2; 中级场可以配置为2小局, 底分5; 因此可以再进一步抽象为 先提供一个可供选择的规则配置 需要什么样的规则, 只要提供对应的choose, 就可以生成具体的tagRoomRule 房间规则配置\n目标 金币场, 比赛场, 俱乐部模式 更好的配置游戏规则 对于房卡场, 服务器控制client的房间规则显示 client开发的时候 不需要做任何处理 client使用流程 client申请创建房间 server判断是否符合创建条件, 发送房间规则配置 rule_arry(在STR_Game.proto中) 其中css控制client显示的样式 rule表示一条规则 css 1 2 特殊规则 3, 4, 5 rule_1 人数 rule_2 局数 rule_3 炸弹 rule_4 鬼子 rule_5 天王九 人 数 \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; 局 数 \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; 特殊规则 炸弹o 鬼子o 天王九o client返回 选择结果 repeated int32 比如: 上面选择了 2人 4局, 则返回 0 2 每个返回字段为byte, 返回的value index server收到后, 构造房间规则tagRoomRule 其他游戏模式使用流程 对于金币场,比赛场等使用更加简单, 直接提供choose_values即可 server\u0026ndash;子游戏 # 子游戏处理范围 游戏开始 \u0026ndash; 大局结束 子游戏不涉及到玩家的财富 只会通知frame增减财富 client子游戏玩家财富信息的显示, 实际由frame控制, 而非子游戏 组织架构 # FrameWork \u0026ndash;\u0026gt; TableFrameSink \u0026ndash;\u0026gt; GameData 备注: 1. tableFrameSink只是处理流程, 所有的数据都在GameData中 CGameCardConfig 是GameData的辅助类. 牌类数据描述 # 玩家 使用16位表示 高四位 表示 玩家类型的ID \u0026ndash; 比如 地主, 农民 再四位 表示 玩家数量 低8位 表示 玩家手牌数量 牌使用16位表示 高四位 表示 卡牌点数 中四位 表示 卡牌颜色 低8位 表示 卡牌类型组 \u0026ndash; groupID, 配置文件挂钩 1方块; 2梅花; 3红桃; 4黑桃; 5表示特殊牌, 比如大王小王 大王小王 花色为5， 值分别为 15 14 protobuf结构 # 消息号 游戏状态 (抢庄, 下注, 发牌 \u0026hellip;.) \u0026ndash; 断线重连相关 自定义enum, 比如牌型, 定时器等 消息号对应的结构体 断线重连对应的结构体 \u0026ndash; 与游戏状态一一对应 战绩中 显示的子游戏信息 redis # 已使用字段 # 含义 key val val_type_in_redis 场景 备注 玩家信息 player_$uid tagUserInfo string 数据库与svr缓存 暂时未使用 排行榜 rank_$rankid zset\u0026lt;uid,score\u0026gt; ordered_set rank data 排行榜过期时间 rank_$rankid_expire int64_t string 毫秒 玩家任务状态 task_status_$uid_$taskid tagTaskstatus string task data uggr索引 gate_$uid gatesvr_id string uid在哪个gateSvr 不含机器人 玩家在多个gateSvr重复登陆时候, 校验 暂时未使用 uggr索引 room_$uid roomsvr_id string uid在哪个roomSvr 不含机器人 只在uid登陆gate时候, gate用来记录map\u0026lt;uid, room\u0026gt; 后续map\u0026lt;uid, room\u0026gt; 通过roomSvr主动通知gate 可用桌子号 table set\u0026lt;tableid\u0026gt; unordered_set 已用桌子号 table_using zset\u0026lt;tableid, time\u0026gt; unordered_set 已用桌子号 table_using_$tableid $severid_$kindid string gateSvr用来查询tableid在哪个server上面 已使用lock字段 # 含义 key 备注 玩家信息锁 lock_player_$uid TODO server\u0026ndash;redis # redis 控制服务 初始化redis redis中机器人对回收等 "},{"id":12,"href":"/blog/posts/server_view/","title":"Server View","section":"Posts","content":" 服务器架构 # logic view # @startuml client -\u0026gt; gate : test @enduml implementation view # process view # deployment view # TODO 后期补充k8s部署下的 deployment view use case view # 服务器说明 # 服务器 说明 有状态 状态量 业务多线程 业务多线程原因 备注 center 路由 n n db 数据库代理 n y database操作耗时 gate 网关 y map[gid, uid] n 无业务逻辑 logon 登录 n n lobby 大厅 n n game 查询, 创建, 加入 房间 n n 加载了房卡场与金币场的配置文件 match 比赛场服务器 y match自身数据stage_index等 n match_manager有map\u0026lt;int,match\u0026gt; room 游戏房间的具体处理 y 房间数据 n rank 排行榜 y rank_manager有map\u0026lt;int,rank\u0026gt; n redis 维护redis数据 n n task 任务 y task_manager有map\u0026lt;int,task\u0026gt; n chat 聊天服务器 n n ready to write club 俱乐部服务器 n n ready to write client 模拟client测试 y ugmanager有map\u0026lt;gid,uid\u0026gt; n 什么时候使用业务多线程 当业务逻辑的处理时间耗时较久的时候, 使用业务多线程 业务多线程优点 是加快了速度 业务多线程缺点 编码复杂(增加了出错概率) "}]