[{"id":0,"href":"/blog/docs/server/architecture/","title":"服务器架构","section":"server","content":"服务器架构# architecture-beta %% client service client(internet)[Client] %% Server group servers(server)[Servers] service gate(server)[Gate] in servers service room(server)[Room] in servers gate:R \u0026lt;-- L:room %% 数据层 group dbs(database)[Databses] service redis(database)[Redis] in dbs service postgres(database)[Postgres] in dbs redis:R -- L:postgres %% 指向 client:R --\u0026gt; L:gate gate:B --\u0026gt; T:redis{group}服务器说明# 服务器 模块 说明 有状态 备注 gate login 登陆 n lobby 大厅 n game 查询/创建/加入 房间 n match 比赛场 y rank 排行榜 y task 任务 y center 数据转发 n room 游戏房间 y redis postgresSQL 业务模块# 基础模块： login room / config \u0026ndash; Server自身读取 game \u0026ndash; 类似于服务注册 table 流程处理了 上面是最基本的模块，下面的都是扩展. 也是相对比较独立的模块. rank task match club activity "},{"id":1,"href":"/blog/docs/server/02_message_flow/","title":"消息流向","section":"server","content":"Message Flow# flowchart TD Start@{ shape: sm-circ, label: \u0026#34;Small start\u0026#34; } %% RPC? Start --\u0026gt; |read message| A{RPC Message} A --\u0026gt; |yes| 1[RPC Handler] A --\u0026gt; |no | B[\u0026#34;Event OnRead()\u0026#34;] %% Internal Message B --\u0026gt; C{Internal Messsage} C --\u0026gt; |yes| 2[Route Message] C --\u0026gt; |no | D[Client Message Handler] %% 模块分组 subgraph Modules[\u0026#34;Modules\u0026#34;] Module_Login[Login Module] Module_Game[Game Module] Module_Other[Other Module] end %% 根据 Message Main 分发到不同模块 D --\u0026gt; |Main = Login| Module_Login D --\u0026gt; |Main = Game| Module_Game D --\u0026gt; |other| Module_Other qykernel read Message时, 判断是否RPC Message 根据message (main, sub)判断的. 在qykernel中定义 如果是RPC Message, 则在qykernel内部处理 如果非RPC Message, 则交给Event(传递到上层)处理 Event::OnRead() 判断是否为 Internal Message 根据Session中的server_name判断. 内部的server都有对应的name 如果是Internal Message, 则表明是route给client的 因为Server之间都是通过service(RPC Message)沟通, 所以internal message只能是route message 如果是Client Message, 则根据message(main, sub)分给不同的module处理 Client Message \u0026lt;-\u0026gt; RoomServer RoomServer本质也是module. 只是没有集成在GateServer中. 当client message -\u0026gt; GateServer(route) -\u0026gt; RoomServer时候 如果是Client刚要进入RoomServer, GateServer根据map\u0026lt;session, ServerType\u0026gt;找到RoomServer, 并route; 如果是已经在RoomServer了, GateServer根据map\u0026lt;session, uid\u0026gt;找到Client对应的uid, 再根据 map\u0026lt;uid, room_session\u0026gt;找到对应的RoomServer, 并route 如果是RoomServer message -\u0026gt; GateServer(route) -\u0026gt; client. 这时候的messge中会包含uid信息, GateServer根据UserManager找到UserInfo, 再找到对应的gate_session并转发 "},{"id":2,"href":"/blog/docs/server/04_ticket/","title":"门票 Ticket","section":"server","content":"门票# 背景# 房间类型 相关设置 备注 房卡场 支付类型, 局数, 人数(房主支付时) 金币场 正常不需要 比赛场 俱乐部 详细说明# 房卡场 门票: 房卡场门票 与 局数有对应关系, 而每个游戏门票又都不同. 因此可以把 门票与局数 应该有对应关系, 而且每个子游戏可以单独配置 房卡场门票 支付类型为房主的时候, 门票与人数就有关系了. 当AA时候每人需要支付1 fk, 则变为房主支付的时候, 就变为了1 * player_count fk 金币场 门票: 金币场不需要门票. 当门票检测和扣除是通用的, 因此如果要配置也可以. 比赛场 门票: 一般都是可配置的 扣除流程# 房卡场 可能在创建房间 或者 一局结束之后 才进行扣除 金币场 比赛场 在报名的时候扣除 TODO 门票 与 房间规则# 因为每个房间中的门票可以不同, 因此放在了房间规则中. 但房间规则应该 与 房间类型无关. (房卡场, 金币场, 比赛场等) 所以应该由房间类型 相关的结构体 包含门票信息, 而非房间规则. 假设独立出来, 不放在RoomRule# 房间规则: 不负责门票的处理 RoomRule CommonRule SubRule FkTicket payment player_count pay_type pay_count game_count GoldTicket fee MatchTicket pay_type pay_count 那么配置文件要如何改动? 现在配置文件有个问题就是 校验规则 其实放在了fk.toml中 比如gold.toml中其实只是类比client配置了rule value, 还是要去fk.toml中进行校验 获取RoomRule "},{"id":3,"href":"/blog/docs/server/03_game/","title":"房间配置","section":"server","content":"房间规则# 房间规则在proto::RoomRule. 其中RoomRuleCommon 为room通用规则, subrules则是子游戏特有 游戏规则(包含RoomServer与子游戏)主要分为两部分: 一部分是静态规则, 游戏本身默认俗称的 或者 是我们默认俗称的. 这部分规则一般在代码中写死的, 比如斗地主本身的规则; 另一部分则是可变化的规则, 比如两人斗地主, 三人斗地主; 这部分可暴露的规则, 被提取为房间规则 根据是否通用(比如几人玩, 玩几局等)又细分为通用规则和子游戏特有规则 房间配置# 目的# 房间配置就是为了获取房间规则. 房卡场 proto::FkRuleConfig 金币场 proto::GoldRuleConfig 重点# Server一定要检验Client传递的数据 流程# RoomServer 启动的时候, 加载{kindid}.fk.toml, {kindid}.gold.toml RoomServer 连接GateServer之后, 根据room.toml中的[room] type来发送相应数据给GateServer GateServer 保存 RoomServer session 和 kindid \u0026lt;\u0026lt; 16 + goldlevel的映射 map \u0026lt;session, vecotr\u0026lt;kg\u0026gt;\u0026gt;, map\u0026lt;kg, vector\u0026lt;session\u0026gt;\u0026gt; 同时GateServer 也保存FkRuleConfig, GoldRuleConfig 玩家登陆成功的时候, 下发FkRuleConfig "},{"id":4,"href":"/blog/docs/server/server/","title":"约定俗称","section":"server","content":"一些约定俗称的 规范 消息号命名规范# 消息号 驼峰式命名 -\u0026gt; kSubQueryGoldRooms 结构体 消息号去掉k -\u0026gt; SubQueryGoldRooms 函数 结构体加On -\u0026gt; OnSubQueryGoldRooms 消息号 含义 第一个字段 k. 表示常量 第二个字段 归属标志. 可能的赋值: Sub C端向S端查询 Cmd S端返回给C端 第三个字段 意图 增删改查 第四个字段 对象 被op对象 \u0026ndash; 可以没有 第无个字段 消息号含义 TODO 玩家的桌子号 (待删除)# player.tableid 含义: 玩家在哪个桌子上 用途: 登录的时候 判断断线重连 进入table时的校验, 防止加入2张桌子 状态变化: roomSvr table加入|坐下, 设置为桌子的tableid roomSvr table离开, 如果是比赛场,设置为MATCH_TABLE, 否则INVALID_TABLE matchSvr 报名成功, 设置为MATCH_TABLE matchSvr 取消报名, 设置为INVALID_TABLE 房间流程# 创建房间 \u0026ndash; 门票检测, 房间规则显示 RoomServer处理 房间规则使用rule_arry结构体传送给客户端显示 加入房间 \u0026ndash; 门票检测 GameServer处理 门票检测时 也会进行游戏资格检测 房间规则在子游戏的显示 RoomServer frame处理 frame调用子游戏SubRuleDes()接口, 显示子游戏规则描述信息 玩家信息在子游戏的显示 RoomServer frame处理 玩家站起|坐下|准备|离开等动作, 会携带玩家信息, 发送给client client根据动作, 判断是绘制还是删除玩家 玩家财富变更后, LogonServer会通知client, 更改大厅的显示 如果在子游戏中, RoomServer frame会通知client, 更改子游戏的显示 即SubGame子游戏不再提供玩家分数相关信息给client 游戏开始|一小局后 \u0026ndash; 门票扣除 RoomServer frame处理 门票扣除信息 在RoomRuleCom中, 由GameServer生成 每小局游戏结束 \u0026ndash; 游戏小局结算 RoomServer frame处理 小局结算写分 战绩记录 录像回放 每局游戏结束后 \u0026ndash; 游戏资格检测 RoomServer frame处理 数据在RoomRuleCom中, 由GameServer提供, 由CenterServer实际处理 "},{"id":5,"href":"/blog/docs/server/gate/","title":"gate","section":"server","content":"gate server server-gate# logon# 重复登陆# 在当前gateSvr中重复登陆 auto player = player_manager.get(uid); player.gatesvr_session != player.current_session 就认为是重复登陆 在所有gateSvr中重复登陆 redis中存在 key=gate_$uid, val=gatesvrid redis.val != current_serverid 说明该uid正在其他gateSvr上. 认为重复登陆 重复登陆处理 在当前gateSvr中重复登陆, 可以直接关闭旧的连接 在其他gateSvr中重复登陆, 需要通过 ?? 通知对应的gateSvr, 关闭玩家连接 断线重连# 判断依据 玩家登陆的时候, redis中存在 key=room_$uid, val=roomsvrid gateSvr会向roomSvr确认玩家是否真的在roomSvr中, 如果roomSvr返回在, 则认为玩家是断线重连 断线处理 gateSvr更新player的roomsvrid信息 通知client game# 房间信息查询 数据来源于roomSvr. roomSvr连接成功之后, 会主动推送 数据格式# 房卡场 \u0026ndash; 查询房间配置: file: cfg_fk.hh data: map\u0026lt;kindid, rule_arry\u0026gt; 金币场 \u0026ndash; 查询金币场信息 file: cfg_gold.hh data: map\u0026lt;kindid, vector\u0026lt;gold_msg\u0026gt;\u0026gt; roomSvr信息 file: server_manager data: map\u0026lt;session, vec\u0026lt;kind+level\u0026gt;\u0026gt; map\u0026lt;vec\u0026lt;kind+level\u0026gt;, session\u0026gt; 保留roomSvr的意义: 如果roomSvr与gateSvr断开连接了, 那么就可以实时的更新3个data数据. 保证client那边看到的永远是可用的服务器 center# 路由clien \u0026lt;-\u0026gt;roomSvr client -\u0026gt; gate -\u0026gt; roomsvr 依据\u0026lt;player, roomsvrid\u0026gt; \u0026lt;x_session, roomsvrid\u0026gt;路由 不使用redis的room_$uid是因为redis承载量不够 roomsvr -\u0026gt; gate -\u0026gt; client 依据\u0026lt;player, client_session\u0026gt;路由 \u0026lt;player, roomsvrid\u0026gt; 在player_manager中维护 玩家登陆成功时候, 根据redis中room_$uid来确认 玩家在roomSvr中加入或退出的时候, roomSvr也会主动推送给gateSvr. \u0026lt;x_session, roomsvrid\u0026gt; 在server_manager中维护 对外接口# SetRoomID(uid, roomsvrid) TODO server\u0026ndash;match# 设计理念# matchSvr负责维护 {uid, score} 排行, 具体的数据是roomSvr通知的matchSvr match没有必要把同排行的人放到一个roomSvr, 因此不需要指定roomSvr 组织架构# kind1 -- match-type 1 -- match 1 -- {对应一系列桌子} -- .... -- match N -- .... -- match-type N .... kind N流程# 玩家申请加入某个比赛场match_type, 如果没有空的match, 则创建一个match, 放入玩家 设置其tableid为MATCH_TABLE, 防止进入其他桌子 如果玩家取消比赛, tableid重置为INVALID_TABLE 玩家掉线的时候, 如果还在比赛排队状态(tableid为MATCH_TABLE), 则按取消比赛处理 当match满足触发条件之后, 开始比赛 matchSvr把玩家分组, 并通知roomSvr创建桌子 roomSvr进行游戏, 当table大局结束的时候, 把数据(score)返回给matchSvr matchSvr进行排序, 重新分组, 继续通知roomSvr开始游戏 循环直至比赛结束为止 依赖关系# 依赖GameSvr, 需要GameSvr提供的GetRoomRule()接口 缺陷# 有状态的, 需要后期改为无状态服务器 配置文件# 配置文件放在subgames/kinid/kindid.match中 TODO server\u0026ndash;rank# 对外接口# PushRank(ranktype, uid, score) 配置文件# 配置文件放在database rank表 id rank_name rank_desc type sortid award valid 自增 名字 描述 类型(唯一标志) 优先级 奖励 是否开启 定时功能的设计# 自定义定时操作 缺点非常明显, 如果Svr挂了, 那么可能会导致数据错乱 所以需要额外考虑svr挂掉的情况 server\u0026ndash;task# 对外接口# PushTask(task_type, uid, score) 流程图# +--------+ | start | +--------+ | | v +--------+ 否 | 触发 |------------+ +--------+ | 是| | | | v | +--------+ 否 | | 完成 | -----+ | +--------+ | | | | | 是 | | | v | | +--------+ | | | updata | \u0026lt;----+ | +--------+ | | | +---v----+ | | end | \u0026lt;----------+ +--------+ 触发条件判断 时间start - end范围 特定kind, 特定room_level下的任务. 比如完成斗地主高级场一次 用户身份的限定 比如vip才可完成的任务 完成条件的判断 需要先根据周期重置来重置任务完成状况 任务完成状况与task配置中的任务step_all比较, 判断是否完成 update 更新任务完成状况 配置文件 \u0026amp;\u0026amp; 中间状态# 配置文件放到database task表 名称 描述 类型 优先级 开始时间 结束时间 重置周期 其他触发限制 总步数 奖励配置 name desc type priority start_time end_time reset_period on_xml step_all award type解释, 斗地主初级场1次, 斗地主初级场2次, 斗地主初级场3次 那么他们的type可以一致, 并设置priority分别为1,2,3 这样就可以认为这三个任务是阶段性任务. 先完成斗地主初级场1次后, 才会显示斗地主初级场2次; 完成斗地主初级场2次后,才会显示斗地主初级场3次. 形成一个阶段 所以type相同, 认为是同一种类型任务(触发流程, 完成流程都一致), 而priority可以区分其阶段. 中间状态放到redis task_status_$uid_$taskid表 uid 任务id 当前步数 任务完成时间 任务状态 uid taskid step_current time status time应该是任务完成的时间. 昨天完成的时间, 到了今天也会重置 status 0 未完成, 1完成未领奖, 2完成已领奖 任务类的设计# Task tagTask 任务配置的数据结构 触发逻辑判断 task::bOn(\u0026hellip;) 入参可能较多 完成逻辑判断 task::bComplete(tagTaskStatus) TaskManager map\u0026lt;taskid, Task\u0026gt; 更新逻辑 TaskManager::updata() 获取不同mtype(或sub_type)的任务 增加, 删除任务 "},{"id":6,"href":"/blog/docs/server/room/","title":"room","section":"server","content":"room server room old# 对外接口# GetTable 获取table状态信息 GetTableUser 获取玩家是否在桌子上 EnterTable(uid, tableid) 进入桌子 EnterTable(uid, tagRoomrule) 进入桌子 EnterTable(vector\u0026lt;uid\u0026gt;, tagRoomrule) 进入桌子 table设计思路# roomSvr中的table是最基本的table, 不考虑金币场, 比赛场, 俱乐部 只处理游戏逻辑 也就是说, 这里Table不区分房卡场, 金币场等 对自身影响范围: 门票的问题 门票无需特意处理, 因为在创建房间之前, 门票就已经算清楚了 算分的问题 只是把结果放出来, 至于具体如何处理, table可以不需要关心 战绩 \u0026amp;\u0026amp; 录像回放# 查询# 数据存放在database中 player_score 战绩-玩家信息 table_record 战绩-桌子信息 table_video 录像回放 模拟运行: 查看大局战绩 player_score与table_record联查, onlyid为连接标志 根据player_score.userid 与 table_record.clubid 找出top 100的onlyid 根据onlyid和curcount=0 在player_score中查找所有符合条件的数据 最后联查player, 联查标记为userid 查看小局战绩 根据onlyid 在player_score查找即可 最后联查player, 联查标志位userid 查看录像回放 根据onlyid, curcount 在table_video中查找即可 录像回放 写入# RoomServer frmae中处理, 子游戏不需要考虑 frame的SendTable()函数中, 调用录像类记录 在小局结束的时候, 调用录像类获取数据 这里的数据是proto序列化为string后, 又转为了raw-string, 方便写入数据库 数据库读取出raw-string, 转为string, 再转为录像数据table_video结构体 子游戏只需要解析table_video即可 小局结束 数据处理# 玩家 门票 玩家 财富变更 玩家 具体输赢情况 玩家 任务系统 桌子 战绩 桌子 回放 财富变更表 \u0026ndash; 比较独立的表格 player_log_treasure 玩家id 财富类型 财富数量 备注说明 插入时间 玩家输赢情况表 player_score 玩家id 当前桌子局数 椅子位置 分数 大赢家标志 唯一标志 插入时间 战绩表 table_record 桌子ID 桌子类型(房卡, 金币) 总局数 桌子玩家数 KindID clubid 子游戏信息 唯一标志 插入时间 战绩回放表 table_video 当前桌子局数 回放数据 唯一标志 插入时间 备注说明: 玩家财富变更均通过 玩家财富变更记录表 \u0026ndash; 所有财富类型 战绩表 只 记录桌子信息, 而不记录 玩家输赢信息 玩家动作 坐下|起立|离开|解散|换桌(金币场)# 玩家加入 玩家坐下 玩家起立 玩家离开 金币换桌 旁观的处理# 是否旁观是由服务器根据桌子状态来判断的玩家加入房间的时候 如果房间已经开始\u0026amp;\u0026amp;允许旁观, 则可以设置为旁观状态 如果房间没有开始, 则是坐下状态 玩家状态# 状态1 UserStatusL 状态2 UserStatusH 两者非互斥关系, UsetStatusL内部为互斥关系, UserStatusH内部为互斥关系 掉线之后未必为托管状态, 掉线8s之后, 将由掉线状态变为托管状态; 当掉线回来后, 托管状态自动取消//用户状态 low enum UserStatusL { FREE_L=0; //没有状态 SIT = 1; //坐下 STANDUP =2; //站立(旁观) READY= 3; //准备状态 PLAYING=4; //游戏中 }; //用户状态 high 与low不互斥 enum UserStatusH { FREE_H =0; //正常状态 TUOGUAN =1; //托管 OFFLINE=2; //掉线 -- 掉线8s之后设置为托管状态 };椅子视图# 唯一视图 真实的椅子位置 frame: m_player_list与真实椅子视图 是通过CPlayer来转换的 subgame: subgame实现了真实的椅子视图 client: client存在C视图 与 真实椅子视图(S视图)的转换 tableid生成方式# table 由redis启动的时候预先生成100000-999999 table_using使用zset记录tableid, 创建time. 后面删除的时候, 根据time来有选择的删除, 比如删除5分钟之前的桌子, 提高效率. 房间配置加载# 加载子游戏的fk, gold, match信息 配置文件# 配置文件放在 kindid/cfg/kindid.fk kindid/cfg/kindid.gold kindid/cfg/kindid.match 房间规则配置# 房间规则分析\n房间规则由来 对于每一个具体的游戏来讲, 游戏本身是规则下的流程 这里的规则分为两大类 一类是游戏自身的规则, 比如斗地主需要一副牌, 有三带一等各种牌型. 这种规则本身变化不大, 影响的是游戏自身的流程. 还有一类规则是影响游戏逻辑之外的, 比如3小局, 4小局. 比如这是房卡场的, 金币场的等等 于是我们把所有游戏共用的规则(主要是第二类规则), 提取出来放到tagRoomRuleCom 而对于每个子游戏不同的游戏规则, 我们只需要提供map\u0026lt;key, choose_index\u0026gt;给子游戏即可 房间规则不区分游戏玩法. 房卡场, 金币场, 比赛场, 俱乐部玩法的房间规则使用同一个结构体tagRoomRule 通用房间规则 是指抽象出来供frame使用的, 使用统一结构体tagRoomRuleCom 子游戏规则 是每个子游戏自身的规则, 在frame层以map\u0026lt;key, choose_index\u0026gt;的形式传递给子游戏, 由子游戏自己解析 房间规则继续分析 无论对于tagRoomRuleCom 还是map\u0026lt;key, choose_index\u0026gt; 都可以认为是key, value的键值对 所以我们配置文件, 可以采取最基本的key, value形式. 但是考虑到房卡场, 金币场等具体玩法, 我们期待的金币场也可以配置自身的游戏规则. 比如初级场可以配置为3小局, 底分2; 中级场可以配置为2小局, 底分5; 因此可以再进一步抽象为 先提供一个可供选择的规则配置 需要什么样的规则, 只要提供对应的choose, 就可以生成具体的tagRoomRule 房间规则配置\n目标 金币场, 比赛场, 俱乐部模式 更好的配置游戏规则 对于房卡场, 服务器控制client的房间规则显示 client开发的时候 不需要做任何处理 client使用流程 client申请创建房间 server判断是否符合创建条件, 发送房间规则配置 rule_arry(在STR_Game.proto中) 其中css控制client显示的样式 rule表示一条规则 css 1 2 特殊规则 3, 4, 5 rule_1 人数 rule_2 局数 rule_3 炸弹 rule_4 鬼子 rule_5 天王九人 数 \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; 局 数 \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; 特殊规则 炸弹o 鬼子o 天王九o client返回 选择结果 repeated int32 比如: 上面选择了 2人 4局, 则返回 0 2 每个返回字段为byte, 返回的value index server收到后, 构造房间规则tagRoomRule 其他游戏模式使用流程 对于金币场,比赛场等使用更加简单, 直接提供choose_values即可 room new# 其中room模块是最容易出错的，继续细分 EnterTable 校验和处理 在table中的处理 LevealTable 上面的有点糙，先不管，继续整理出来思路 table的概念设计 类比真实的 桌子 玩家找到一个空闲的桌子， 在桌子上找一个空闲椅子 在椅子上坐下 表示准备好了 等所有人准备好了，开始游戏 玩家和椅子： sit，up，ready 玩家和table enter，leave enter table，但没有sit on chair就表示旁观 table自身拆分为一系列小的组合. 比如游戏结束的处理就专门给sub_gameend. table 只负责流程， 具体处理扔给后面的handler ready 要不要是与椅子的交互呢？ table肯定是enter和leave 两种动作 chair肯定也有sit和up 如果ready不是与椅子的交互，又是什么呢？ 玩家状态in table free - 刚刚Enter table sit — sit on chair ready — ready action playing — 游戏开始了 table状态： free - 游戏未开始 playing - 游戏开始了 xj end 小局结束了 dj end 大局结束了 "},{"id":7,"href":"/blog/docs/server/redis/","title":"redis","section":"server","content":"redis redis old# 已使用字段# 含义 key val val_type_in_redis 场景 备注 玩家信息 player_$uid tagUserInfo string 数据库与svr缓存 暂时未使用 排行榜 rank_$rankid zset\u0026lt;uid,score\u0026gt; ordered_set rank data 排行榜过期时间 rank_$rankid_expire int64_t string 毫秒 玩家任务状态 task_status_$uid_$taskid tagTaskstatus string task data uggr索引 gate_$uid gatesvr_id string uid在哪个gateSvr 不含机器人 玩家在多个gateSvr重复登陆时候, 校验 暂时未使用 uggr索引 room_$uid roomsvr_id string uid在哪个roomSvr 不含机器人 只在uid登陆gate时候, gate用来记录map\u0026lt;uid, room\u0026gt; 后续map\u0026lt;uid, room\u0026gt; 通过roomSvr主动通知gate 已用桌子号 tableid_$tableid $severid string gateSvr用来查询tableid在哪个server上面 已使用lock字段# 含义 key 备注 玩家信息锁 lock_player_$uid TODO server\u0026ndash;redis# redis 控制服务 初始化redis redis中机器人对回收等 redis new# 已使用字段# 含义 key val val_type_in_redis 场景 备注 已用桌子号 tableid_$tableid $severid string gateSvr用来查询tableid在哪个server上面 "},{"id":8,"href":"/blog/docs/server/subgame/","title":"subgame","section":"server","content":"subgame server\u0026ndash;子游戏# 子游戏处理范围 游戏开始 \u0026ndash; 大局结束 子游戏不涉及到玩家的财富 只会通知frame增减财富 client子游戏玩家财富信息的显示, 实际由frame控制, 而非子游戏 组织架构# FrameWork \u0026ndash;\u0026gt; TableFrameSink \u0026ndash;\u0026gt; GameData 备注: 1. tableFrameSink只是处理流程, 所有的数据都在GameData中 CGameCardConfig 是GameData的辅助类. 牌类数据描述# 玩家 使用16位表示 高四位 表示 玩家类型的ID \u0026ndash; 比如 地主, 农民 再四位 表示 玩家数量 低8位 表示 玩家手牌数量 牌使用16位表示 高四位 表示 卡牌点数 中四位 表示 卡牌颜色 低8位 表示 卡牌类型组 \u0026ndash; groupID, 配置文件挂钩 1方块; 2梅花; 3红桃; 4黑桃; 5表示特殊牌, 比如大王小王 大王小王 花色为5， 值分别为 15 14 protobuf结构# 消息号 游戏状态 (抢庄, 下注, 发牌 \u0026hellip;.) \u0026ndash; 断线重连相关 自定义enum, 比如牌型, 定时器等 消息号对应的结构体 断线重连对应的结构体 \u0026ndash; 与游戏状态一一对应 战绩中 显示的子游戏信息 "},{"id":9,"href":"/blog/docs/server/22/","title":"牌九","section":"server","content":"保定牌九 流程图# flowchart TD Start --\u0026gt; if1{当前局数\u0026gt;4} if1 --\u0026gt;|no| 抢庄 --\u0026gt; 下注 --\u0026gt; 发牌 --\u0026gt; 摊牌 --\u0026gt; 结算 --\u0026gt; if2{是否大局结束} if1 --\u0026gt;|yes| if3{切锅} if3 --\u0026gt;|yes| 结算 if3 --\u0026gt;|no| 抢庄 if2 --\u0026gt;|yes| End if2 --\u0026gt;|no| 抢庄"},{"id":10,"href":"/blog/posts/readme/","title":"Readme","section":"Posts","content":"目录说明# path desc org blog org源码 static hugo静态文件 config.toml hugo配置文件 流程# push触发github action 下载 clay9/emacs.git 执行init-for-script.el, export org to md 执行hugo的编译, export md to html 执行hugo的发布 "},{"id":11,"href":"/blog/posts/repository/","title":"Repository","section":"Posts","content":"构建流程# qydocker与qygame协同工作, 构建docker images. 具体流程如下图: qydocker# 管理docker image. 负责image构建与运行. 托管在qydocker organization 仓库名 作用 qydocker/build_image_dev 构建qygame base image qydocker/build_publish 编译qygame, 结果托管在qygame/svr-publish qydocker/build_image 构建qygame images qydocker/docker-compose 使用docker-compose管理qygame images qydocker/k8s 使用k8s管理qygame images qydocker/mirror_google_image google docker镜像映射到dockerhub, 加快访问速度 qygame# 管理游戏源码, 主要有server端代码, client代码, protocol协议, database. 托管在qygame organization 仓库名 作用 备注 qygame/svr-kernel 业务与基础库的适配层 qygame/svr-frame 业务层 依赖svr-kernel qygame/svr-subgames 子游戏 依赖svr-frame qygame/protocol client与server消息协议 qygame/client client qygame/database 数据库 qygame/svr-publish 以branch形式存放svr编译结果 "}]