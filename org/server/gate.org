#+title: gate
#+date: 2025-10-02 18:04:59
#+hugo_section: docs
#+hugo_bundle: server/gate
#+export_file_name: index
#+hugo_weight: 12
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

gate server

#+hugo: more

* server-gate
** logon
*** 重复登陆
    *在当前gateSvr中重复登陆*
    auto player = player_manager.get(uid);
    player.gatesvr_session != player.current_session 就认为是重复登陆


    *在所有gateSvr中重复登陆*
    redis中存在 key=gate_$uid, val=gatesvrid
    redis.val != current_serverid 说明该uid正在其他gateSvr上. 认为重复登陆


    *重复登陆处理*
    在当前gateSvr中重复登陆, 可以直接关闭旧的连接
    在其他gateSvr中重复登陆, 需要通过 ?? 通知对应的gateSvr, 关闭玩家连接
*** 断线重连
    *判断依据*
    玩家登陆的时候,
    redis中存在 key=room_$uid, val=roomsvrid
    gateSvr会向roomSvr确认玩家是否真的在roomSvr中,
    如果roomSvr返回在, 则认为玩家是断线重连

    *断线处理*
    1. gateSvr更新player的roomsvrid信息
    2. 通知client
** game
   房间信息查询
   数据来源于roomSvr. roomSvr连接成功之后, 会主动推送

*** 数据格式
    房卡场 -- 查询房间配置:
    file: cfg_fk.hh
    data: map<kindid, rule_arry>

    金币场 -- 查询金币场信息
    file: cfg_gold.hh
    data: map<kindid, vector<gold_msg>>

    roomSvr信息
    file: server_manager
    data:
    map<session, vec<kind+level>>
    map<vec<kind+level>, session>

    保留roomSvr的意义:
    如果roomSvr与gateSvr断开连接了, 那么就可以实时的更新3个data数据.
    保证client那边看到的永远是可用的服务器

** center
   路由clien <->roomSvr
   - client -> gate -> roomsvr
     依据<player, roomsvrid> <x_session, roomsvrid>路由
     不使用redis的room_$uid是因为redis承载量不够
   - roomsvr -> gate -> client
     依据<player, client_session>路由

   <player, roomsvrid> 在player_manager中维护
   1. 玩家登陆成功时候, 根据redis中room_$uid来确认
   2. 玩家在roomSvr中加入或退出的时候, roomSvr也会主动推送给gateSvr.

   <x_session, roomsvrid> 在server_manager中维护

*** 对外接口
    - SetRoomID(uid, roomsvrid)

** TODO server--match
*** 设计理念
    matchSvr负责维护 {uid, score} 排行,
    具体的数据是roomSvr通知的matchSvr

    match没有必要把同排行的人放到一个roomSvr, 因此不需要指定roomSvr

*** 组织架构
    #+BEGIN_EXAMPLE
      kind1  --  match-type 1  -- match 1 -- {对应一系列桌子}
                               -- ....
                               -- match N
             --  ....
             --  match-type N
      ....
      kind N
    #+END_EXAMPLE

*** 流程
    1. 玩家申请加入某个比赛场match_type, 如果没有空的match, 则创建一个match, 放入玩家
       设置其tableid为MATCH_TABLE, 防止进入其他桌子
       如果玩家取消比赛, tableid重置为INVALID_TABLE
       玩家掉线的时候, 如果还在比赛排队状态(tableid为MATCH_TABLE), 则按取消比赛处理
    2. 当match满足触发条件之后, 开始比赛
       matchSvr把玩家分组, 并通知roomSvr创建桌子
    3. roomSvr进行游戏, 当table大局结束的时候, 把数据(score)返回给matchSvr
    4. matchSvr进行排序, 重新分组, 继续通知roomSvr开始游戏
    5. 循环直至比赛结束为止
*** 依赖关系
    依赖GameSvr, 需要GameSvr提供的GetRoomRule()接口
*** 缺陷
    有状态的, 需要后期改为无状态服务器
*** 配置文件
    配置文件放在subgames/kinid/kindid.match中

** TODO server--rank
*** 对外接口
    - PushRank(ranktype, uid, score)
*** 配置文件
    *配置文件放在database rank表*
    | id   | rank_name | rank_desc | type           | sortid | award | valid    |
    | 自增 | 名字      | 描述      | 类型(唯一标志) | 优先级 | 奖励  | 是否开启 |

*** 定时功能的设计
    自定义定时操作
    缺点非常明显, 如果Svr挂了, 那么可能会导致数据错乱
    所以需要额外考虑svr挂掉的情况

** server--task
*** 对外接口
    - PushTask(task_type, uid, score)
*** 流程图
     #+BEGIN_EXAMPLE
      +--------+
      | start  |
      +--------+
          |
          |
          v
      +--------+  否
      | 触发   |------------+
      +--------+            |
        是|                 |
          |                 |
          v                 |
      +--------+  否        |
      |  完成  | -----+     |
      +--------+      |     |
          |           |     |
       是 |           |     |
          v           |     |
      +--------+      |     |
      | updata | <----+     |
      +--------+            |
          |                 |
      +---v----+            |
      | end    | <----------+
      +--------+
     #+END_EXAMPLE
     1. 触发条件判断
        - 时间start - end范围
        - 特定kind, 特定room_level下的任务.
          比如完成斗地主高级场一次
        - 用户身份的限定
          比如vip才可完成的任务
     2. 完成条件的判断
        1) 需要先根据周期重置来重置任务完成状况
        2) 任务完成状况与task配置中的任务step_all比较, 判断是否完成
     3. update
        更新任务完成状况
*** 配置文件 && 中间状态
    *配置文件放到database task表*
    | 名称 | 描述 | 类型 | 优先级   | 开始时间   | 结束时间 | 重置周期     | 其他触发限制 | 总步数   | 奖励配置 |
    | name | desc | type | priority | start_time | end_time | reset_period | on_xml       | step_all | award    |

    type解释,
    斗地主初级场1次, 斗地主初级场2次, 斗地主初级场3次
    那么他们的type可以一致, 并设置priority分别为1,2,3
    这样就可以认为这三个任务是阶段性任务. 先完成斗地主初级场1次后, 才会显示斗地主初级场2次;
    完成斗地主初级场2次后,才会显示斗地主初级场3次. 形成一个阶段

    所以type相同, 认为是同一种类型任务(触发流程, 完成流程都一致), 而priority可以区分其阶段.


    *中间状态放到redis task_status_$uid_$taskid表*
    | uid | 任务id | 当前步数     | 任务完成时间 | 任务状态 |
    | uid | taskid | step_current | time         | status   |

    time应该是任务完成的时间. 昨天完成的时间, 到了今天也会重置
    status 0 未完成, 1完成未领奖, 2完成已领奖
*** 任务类的设计
     1. Task
        - tagTask 任务配置的数据结构
        - 触发逻辑判断 task::bOn(...) 入参可能较多
        - 完成逻辑判断 task::bComplete(tagTaskStatus)
     2. TaskManager
        - map<taskid, Task>
        - 更新逻辑 TaskManager::updata()
        - 获取不同mtype(或sub_type)的任务
        - 增加, 删除任务
